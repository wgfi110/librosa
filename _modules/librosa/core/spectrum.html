

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>librosa.core.spectrum &mdash; librosa 0.7.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../../',
              VERSION:'0.7.2',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/banner.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> librosa
          

          
          </a>

          
            
            
              <div class="version">
                0.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sequence.html">Sequential modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html">Utilities</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cache.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ioformats.html">Advanced I/O Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced.html">Advanced examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">librosa</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>librosa.core.spectrum</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  





<h1>Source code for librosa.core.spectrum</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&#39;&#39;&#39;Utilities for spectral processing&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>
<span class="kn">import</span> <span class="nn">six</span>

<span class="kn">from</span> <span class="nn">numba</span> <span class="k">import</span> <span class="n">jit</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">time_frequency</span>
<span class="kn">from</span> <span class="nn">.fft</span> <span class="k">import</span> <span class="n">get_fftlib</span>
<span class="kn">from</span> <span class="nn">.audio</span> <span class="k">import</span> <span class="n">resample</span>
<span class="kn">from</span> <span class="nn">.._cache</span> <span class="k">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..util.exceptions</span> <span class="k">import</span> <span class="n">ParameterError</span>
<span class="kn">from</span> <span class="nn">..util.decorators</span> <span class="k">import</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">..filters</span> <span class="k">import</span> <span class="n">get_window</span><span class="p">,</span> <span class="n">semitone_filterbank</span>
<span class="kn">from</span> <span class="nn">..filters</span> <span class="k">import</span> <span class="n">window_sumsquare</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;stft&#39;</span><span class="p">,</span> <span class="s1">&#39;istft&#39;</span><span class="p">,</span> <span class="s1">&#39;magphase&#39;</span><span class="p">,</span> <span class="s1">&#39;iirt&#39;</span><span class="p">,</span> <span class="s1">&#39;ifgram&#39;</span><span class="p">,</span>
           <span class="s1">&#39;reassigned_spectrogram&#39;</span><span class="p">,</span>
           <span class="s1">&#39;phase_vocoder&#39;</span><span class="p">,</span>
           <span class="s1">&#39;perceptual_weighting&#39;</span><span class="p">,</span>
           <span class="s1">&#39;power_to_db&#39;</span><span class="p">,</span> <span class="s1">&#39;db_to_power&#39;</span><span class="p">,</span>
           <span class="s1">&#39;amplitude_to_db&#39;</span><span class="p">,</span> <span class="s1">&#39;db_to_amplitude&#39;</span><span class="p">,</span>
           <span class="s1">&#39;fmt&#39;</span><span class="p">,</span> <span class="s1">&#39;pcen&#39;</span><span class="p">,</span> <span class="s1">&#39;griffinlim&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="stft"><a class="viewcode-back" href="../../../generated/librosa.core.stft.html#librosa.core.stft">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span>
         <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Short-time Fourier transform (STFT). [1]_ (chapter 2)</span>

<span class="sd">    The STFT represents a signal in the time-frequency domain by</span>
<span class="sd">    computing discrete Fourier transforms (DFT) over short overlapping</span>
<span class="sd">    windows.</span>

<span class="sd">    This function returns a complex-valued matrix D such that</span>

<span class="sd">    - `np.abs(D[f, t])` is the magnitude of frequency bin `f`</span>
<span class="sd">      at frame `t`, and</span>

<span class="sd">    - `np.angle(D[f, t])` is the phase of frequency bin `f`</span>
<span class="sd">      at frame `t`.</span>

<span class="sd">    The integers `t` and `f` can be converted to physical units by means</span>
<span class="sd">    of the utility functions `frames_to_sample` and `fft_frequencies`.</span>

<span class="sd">    .. [1] M. Müller. &quot;Fundamentals of Music Processing.&quot; Springer, 2015</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)], real-valued</span>
<span class="sd">        input signal</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        length of the windowed signal after padding with zeros.</span>
<span class="sd">        The number of rows in the STFT matrix `D` is (1 + n_fft/2).</span>
<span class="sd">        The default value, n_fft=2048 samples, corresponds to a physical</span>
<span class="sd">        duration of 93 milliseconds at a sample rate of 22050 Hz, i.e. the</span>
<span class="sd">        default sample rate in librosa. This value is well adapted for music</span>
<span class="sd">        signals. However, in speech processing, the recommended value is 512,</span>
<span class="sd">        corresponding to 23 milliseconds at a sample rate of 22050 Hz.</span>
<span class="sd">        In any case, we recommend setting `n_fft` to a power of two for</span>
<span class="sd">        optimizing the speed of the fast Fourier transform (FFT) algorithm.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        number of audio samples between adjacent STFT columns.</span>

<span class="sd">        Smaller values increase the number of columns in `D` without</span>
<span class="sd">        affecting the frequency resolution of the STFT.</span>

<span class="sd">        If unspecified, defaults to `win_length / 4` (see below).</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()` of length `win_length`</span>
<span class="sd">        and then padded with zeros to match `n_fft`.</span>

<span class="sd">        Smaller values improve the temporal resolution of the STFT (i.e. the</span>
<span class="sd">        ability to discriminate impulses that are closely spaced in time)</span>
<span class="sd">        at the expense of frequency resolution (i.e. the ability to discriminate</span>
<span class="sd">        pure tones that are closely spaced in frequency). This effect is known</span>
<span class="sd">        as the time-frequency localization tradeoff and needs to be adjusted</span>
<span class="sd">        according to the properties of the input signal `y`.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        Either:</span>

<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>

<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>

<span class="sd">        - a vector or array of length `n_fft`</span>


<span class="sd">        Defaults to a raised cosine window (&quot;hann&quot;), which is adequate for</span>
<span class="sd">        most applications in audio signal processing.</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        If `True`, the signal `y` is padded so that frame</span>
<span class="sd">        `D[:, t]` is centered at `y[t * hop_length]`.</span>

<span class="sd">        If `False`, then `D[:, t]` begins at `y[t * hop_length]`.</span>

<span class="sd">        Defaults to `True`,  which simplifies the alignment of `D` onto a</span>
<span class="sd">        time grid by means of `librosa.core.frames_to_samples`.</span>
<span class="sd">        Note, however, that `center` must be set to `False` when analyzing</span>
<span class="sd">        signals with `librosa.stream`.</span>

<span class="sd">        .. see also:: `stream`</span>

<span class="sd">    dtype : numeric type</span>
<span class="sd">        Complex numeric type for `D`.  Default is single-precision</span>
<span class="sd">        floating-point complex (`np.complex64`).</span>

<span class="sd">    pad_mode : string or function</span>
<span class="sd">        If `center=True`, this argument is passed to `np.pad` for padding</span>
<span class="sd">        the edges of the signal `y`. By default (`pad_mode=&quot;reflect&quot;`),</span>
<span class="sd">        `y` is padded on both sides with its own reflection, mirrored around</span>
<span class="sd">        its first and last sample respectively.</span>
<span class="sd">        If `center=False`,  this argument is ignored.</span>

<span class="sd">        .. see also:: `np.pad`</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D : np.ndarray [shape=(1 + n_fft/2, n_frames), dtype=dtype]</span>
<span class="sd">        Complex-valued matrix of short-term Fourier transform</span>
<span class="sd">        coefficients.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    istft : Inverse STFT</span>

<span class="sd">    reassigned_spectrogram : Time-frequency reassigned spectrogram</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 20.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; D</span>
<span class="sd">    array([[2.58028018e-03, 4.32422794e-02, 6.61255598e-01, ...,</span>
<span class="sd">            6.82710262e-04, 2.51654536e-04, 7.23036574e-05],</span>
<span class="sd">           [2.49403086e-03, 5.15930466e-02, 6.00107312e-01, ...,</span>
<span class="sd">            3.48026224e-04, 2.35853557e-04, 7.54836728e-05],</span>
<span class="sd">           [7.82410789e-04, 1.05394892e-01, 4.37517226e-01, ...,</span>
<span class="sd">            6.29352580e-04, 3.38571583e-04, 8.38094638e-05],</span>
<span class="sd">           ...,</span>
<span class="sd">           [9.48568513e-08, 4.74725084e-07, 1.50052492e-05, ...,</span>
<span class="sd">            1.85637656e-08, 2.89708542e-08, 5.74304337e-09],</span>
<span class="sd">           [1.25165826e-07, 8.58259284e-07, 1.11157215e-05, ...,</span>
<span class="sd">            3.49099771e-08, 3.11740926e-08, 5.29926236e-09],</span>
<span class="sd">           [1.70630571e-07, 8.92518756e-07, 1.23656537e-05, ...,</span>
<span class="sd">            5.33256745e-08, 3.33264900e-08, 5.13272980e-09]], dtype=float32)</span>

<span class="sd">    Use left-aligned frames, instead of centered frames</span>

<span class="sd">    &gt;&gt;&gt; D_left = np.abs(librosa.stft(y, center=False))</span>


<span class="sd">    Use a shorter hop length</span>

<span class="sd">    &gt;&gt;&gt; D_short = np.abs(librosa.stft(y, hop_length=64))</span>


<span class="sd">    Display a spectrogram</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(D,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># By default, use the entire frame</span>
    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="c1"># Set the default hop, if it&#39;s not already specified</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="n">fft_window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Pad the window out to n_fft size</span>
    <span class="n">fft_window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">fft_window</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># Reshape so that the window can be broadcast</span>
    <span class="n">fft_window</span> <span class="o">=</span> <span class="n">fft_window</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Check audio is valid</span>
    <span class="n">util</span><span class="o">.</span><span class="n">valid_audio</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># Pad the time series so that frames are centered</span>
    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="c1"># Window the time series.</span>
    <span class="n">y_frames</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

    <span class="c1"># Pre-allocate the STFT matrix</span>
    <span class="n">stft_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">y_frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="n">fft</span> <span class="o">=</span> <span class="n">get_fftlib</span><span class="p">()</span>

    <span class="c1"># how many columns can we fit within MAX_MEM_BLOCK?</span>
    <span class="n">n_columns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">MAX_MEM_BLOCK</span> <span class="o">/</span> <span class="p">(</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                                          <span class="n">stft_matrix</span><span class="o">.</span><span class="n">itemsize</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">bl_s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_columns</span><span class="p">):</span>
        <span class="n">bl_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bl_s</span> <span class="o">+</span> <span class="n">n_columns</span><span class="p">,</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">stft_matrix</span><span class="p">[:,</span> <span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">fft_window</span> <span class="o">*</span>
                                             <span class="n">y_frames</span><span class="p">[:,</span> <span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">],</span>
                                             <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stft_matrix</span></div>


<div class="viewcode-block" id="istft"><a class="viewcode-back" href="../../../generated/librosa.core.istft.html#librosa.core.istft">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">istft</span><span class="p">(</span><span class="n">stft_matrix</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span>
          <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverse short-time Fourier transform (ISTFT).</span>

<span class="sd">    Converts a complex-valued spectrogram `stft_matrix` to time-series `y`</span>
<span class="sd">    by minimizing the mean squared error between `stft_matrix` and STFT of</span>
<span class="sd">    `y` as described in [1]_ up to Section 2 (reconstruction from MSTFT).</span>

<span class="sd">    In general, window function, hop length and other parameters should be same</span>
<span class="sd">    as in stft, which mostly leads to perfect reconstruction of a signal from</span>
<span class="sd">    unmodified `stft_matrix`.</span>

<span class="sd">    .. [1] D. W. Griffin and J. S. Lim,</span>
<span class="sd">        &quot;Signal estimation from modified short-time Fourier transform,&quot;</span>
<span class="sd">        IEEE Trans. ASSP, vol.32, no.2, pp.236–243, Apr. 1984.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stft_matrix : np.ndarray [shape=(1 + n_fft/2, t)]</span>
<span class="sd">        STFT matrix from `stft`</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        Number of frames between STFT columns.</span>
<span class="sd">        If unspecified, defaults to `win_length / 4`.</span>

<span class="sd">    win_length : int &lt;= n_fft = 2 * (stft_matrix.shape[0] - 1)</span>
<span class="sd">        When reconstructing the time series, each frame is windowed</span>
<span class="sd">        and each sample is normalized by the sum of squared window</span>
<span class="sd">        according to the `window` function (see below).</span>

<span class="sd">        If unspecified, defaults to `n_fft`.</span>

<span class="sd">    window : string, tuple, number, function, np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a user-specified window vector of length `n_fft`</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, `D` is assumed to have centered frames.</span>
<span class="sd">        - If `False`, `D` is assumed to have left-aligned frames.</span>

<span class="sd">    dtype : numeric type</span>
<span class="sd">        Real numeric type for `y`.  Default is 32-bit float.</span>

<span class="sd">    length : int &gt; 0, optional</span>
<span class="sd">        If provided, the output `y` is zero-padded or clipped to exactly</span>
<span class="sd">        `length` samples.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        time domain signal reconstructed from `stft_matrix`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft : Short-time Fourier Transform</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; y_hat = librosa.istft(D)</span>
<span class="sd">    &gt;&gt;&gt; y_hat</span>
<span class="sd">    array([ -4.812e-06,  -4.267e-06, ...,   6.271e-06,   2.827e-07], dtype=float32)</span>

<span class="sd">    Exactly preserving length of the input signal requires explicit padding.</span>
<span class="sd">    Otherwise, a partial frame at the end of `y` will not be represented.</span>

<span class="sd">    &gt;&gt;&gt; n = len(y)</span>
<span class="sd">    &gt;&gt;&gt; n_fft = 2048</span>
<span class="sd">    &gt;&gt;&gt; y_pad = librosa.util.fix_length(y, n + n_fft // 2)</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y_pad, n_fft=n_fft)</span>
<span class="sd">    &gt;&gt;&gt; y_out = librosa.istft(D, length=n)</span>
<span class="sd">    &gt;&gt;&gt; np.max(np.abs(y - y_out))</span>
<span class="sd">    1.4901161e-07</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># By default, use the entire frame</span>
    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="c1"># Set the default hop, if it&#39;s not already specified</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="n">ifft_window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Pad out to match n_fft, and add a broadcasting axis</span>
    <span class="n">ifft_window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">ifft_window</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1"># For efficiency, trim STFT frames according to signal length if available</span>
    <span class="k">if</span> <span class="n">length</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">padded_length</span> <span class="o">=</span> <span class="n">length</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">padded_length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="n">n_frames</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">padded_length</span> <span class="o">/</span> <span class="n">hop_length</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_frames</span> <span class="o">=</span> <span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">expected_signal_len</span> <span class="o">=</span> <span class="n">n_fft</span> <span class="o">+</span> <span class="n">hop_length</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_frames</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">expected_signal_len</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">n_columns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">MAX_MEM_BLOCK</span> <span class="o">//</span> <span class="p">(</span><span class="n">stft_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                                           <span class="n">stft_matrix</span><span class="o">.</span><span class="n">itemsize</span><span class="p">))</span>

    <span class="n">fft</span> <span class="o">=</span> <span class="n">get_fftlib</span><span class="p">()</span>

    <span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">bl_s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">,</span> <span class="n">n_columns</span><span class="p">):</span>
        <span class="n">bl_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bl_s</span> <span class="o">+</span> <span class="n">n_columns</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">)</span>

        <span class="c1"># invert the block and apply the window function</span>
        <span class="n">ytmp</span> <span class="o">=</span> <span class="n">ifft_window</span> <span class="o">*</span> <span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">stft_matrix</span><span class="p">[:,</span> <span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Overlap-add the istft block starting at the i&#39;th frame</span>
        <span class="n">__overlap_add</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">frame</span> <span class="o">*</span> <span class="n">hop_length</span><span class="p">:],</span> <span class="n">ytmp</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">)</span>

        <span class="n">frame</span> <span class="o">+=</span> <span class="p">(</span><span class="n">bl_t</span> <span class="o">-</span> <span class="n">bl_s</span><span class="p">)</span>

    <span class="c1"># Normalize by sum of squared window</span>
    <span class="n">ifft_window_sum</span> <span class="o">=</span> <span class="n">window_sumsquare</span><span class="p">(</span><span class="n">window</span><span class="p">,</span>
                                       <span class="n">n_frames</span><span class="p">,</span>
                                       <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
                                       <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
                                       <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                                       <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">approx_nonzero_indices</span> <span class="o">=</span> <span class="n">ifft_window_sum</span> <span class="o">&gt;</span> <span class="n">util</span><span class="o">.</span><span class="n">tiny</span><span class="p">(</span><span class="n">ifft_window_sum</span><span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="n">approx_nonzero_indices</span><span class="p">]</span> <span class="o">/=</span> <span class="n">ifft_window_sum</span><span class="p">[</span><span class="n">approx_nonzero_indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If we don&#39;t need to control length, just do the usual center trimming</span>
        <span class="c1"># to eliminate padded data</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="c1"># If we&#39;re centering, crop off the first n_fft//2 samples</span>
            <span class="c1"># and then trim/pad to the target length.</span>
            <span class="c1"># We don&#39;t trim the end here, so that if the signal is zero-padded</span>
            <span class="c1"># to a longer duration, the decay is smooth by windowing</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we&#39;re not centering, start at 0 and trim/pad as necessary</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">fix_length</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span> <span class="n">length</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y</span></div>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">__overlap_add</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ytmp</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">):</span>
    <span class="c1"># numba-accelerated overlap add for inverse stft</span>
    <span class="c1"># y is the pre-allocated output buffer</span>
    <span class="c1"># ytmp is the windowed inverse-stft frames</span>
    <span class="c1"># hop_length is the hop-length of the STFT analysis</span>

    <span class="n">n_fft</span> <span class="o">=</span> <span class="n">ytmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ytmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">frame</span> <span class="o">*</span> <span class="n">hop_length</span>
        <span class="n">y</span><span class="p">[</span><span class="n">sample</span><span class="p">:(</span><span class="n">sample</span> <span class="o">+</span> <span class="n">n_fft</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">ytmp</span><span class="p">[:,</span> <span class="n">frame</span><span class="p">]</span>


<div class="viewcode-block" id="ifgram"><a class="viewcode-back" href="../../../generated/librosa.core.ifgram.html#librosa.core.ifgram">[docs]</a><span class="nd">@deprecated</span><span class="p">(</span><span class="s1">&#39;0.7.1&#39;</span><span class="p">,</span> <span class="s1">&#39;0.8.0&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ifgram</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ref_power</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
           <span class="n">clip</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute the instantaneous frequency (as a proportion of the sampling rate)</span>
<span class="sd">    obtained as the time-derivative of the phase of the complex spectrum as</span>
<span class="sd">    described by [1]_.</span>

<span class="sd">    Calculates regular STFT as a side effect.</span>

<span class="sd">    .. [1] Abe, Toshihiko, Takao Kobayashi, and Satoshi Imai.</span>
<span class="sd">        &quot;Harmonics tracking and pitch extraction based on instantaneous</span>
<span class="sd">        frequency.&quot;</span>
<span class="sd">        International Conference on Acoustics, Speech, and Signal Processing,</span>
<span class="sd">        ICASSP-95., Vol. 1. IEEE, 1995.</span>


<span class="sd">    .. warning:: This function is deprecated in version 0.7.1, and will be removed</span>
<span class="sd">                 in version 0.8.0.  The function `reassigned_spectrogram` provides</span>
<span class="sd">                 comparable functionality, and should be used instead of `ifgram`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length, number samples between subsequent frames.</span>
<span class="sd">        If not supplied, defaults to `win_length / 4`.</span>

<span class="sd">    win_length : int &gt; 0, &lt;= n_fft</span>
<span class="sd">        Window length. Defaults to `n_fft`.</span>
<span class="sd">        See `stft` for details.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a user-specified window vector of length `n_fft`</span>

<span class="sd">        See `stft` for details.</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    norm : bool</span>
<span class="sd">        Normalize the STFT.</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">            `D[:, t]` (and `if_gram`) is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then `D[:, t]` at `y[t * hop_length]`</span>

<span class="sd">    ref_power : float &gt;= 0 or callable</span>
<span class="sd">        Minimum power threshold for estimating instantaneous frequency.</span>
<span class="sd">        Any bin with `np.abs(D[f, t])**2 &lt; ref_power` will receive the</span>
<span class="sd">        default frequency estimate.</span>

<span class="sd">        If callable, the threshold is set to `ref_power(np.abs(D)**2)`.</span>

<span class="sd">    clip : boolean</span>
<span class="sd">        - If `True`, clip estimated frequencies to the range `[0, 0.5 * sr]`.</span>
<span class="sd">        - If `False`, estimated frequencies can be negative or exceed</span>
<span class="sd">          `0.5 * sr`.</span>

<span class="sd">    dtype : numeric type</span>
<span class="sd">        Complex numeric type for `D`.  Default is 64-bit complex.</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    if_gram : np.ndarray [shape=(1 + n_fft/2, t), dtype=real]</span>
<span class="sd">        Instantaneous frequency spectrogram:</span>
<span class="sd">        `if_gram[f, t]` is the frequency at bin `f`, time `t`</span>

<span class="sd">    D : np.ndarray [shape=(1 + n_fft/2, t), dtype=complex]</span>
<span class="sd">        Short-time Fourier transform</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft : Short-time Fourier Transform</span>
<span class="sd">    reassigned_spectrogram : Time-frequency reassigned spectrogram</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; frequencies, D = librosa.ifgram(y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; frequencies</span>
<span class="sd">    array([[  0.000e+00,   0.000e+00, ...,   0.000e+00,   0.000e+00],</span>
<span class="sd">           [  3.150e+01,   3.070e+01, ...,   1.077e+01,   1.077e+01],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.101e+04,   1.101e+04, ...,   1.101e+04,   1.101e+04],</span>
<span class="sd">           [  1.102e+04,   1.102e+04, ...,   1.102e+04,   1.102e+04]])</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Construct a padded hann window</span>
    <span class="n">fft_window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span>
                                            <span class="n">fftbins</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                                 <span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># Window for discrete differentiation</span>
    <span class="c1"># we use a cyclic gradient calculation here to ensure that the edges of</span>
    <span class="c1"># the window are handled properly</span>
    <span class="n">d_window</span> <span class="o">=</span> <span class="o">-</span> <span class="n">util</span><span class="o">.</span><span class="n">cyclic_gradient</span><span class="p">(</span><span class="n">fft_window</span><span class="p">)</span>

    <span class="n">stft_matrix</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                       <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
                       <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                       <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="n">diff_stft</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                     <span class="n">window</span><span class="o">=</span><span class="n">d_window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                     <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

    <span class="c1"># Compute power normalization. Suppress zeros.</span>
    <span class="n">mag</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">magphase</span><span class="p">(</span><span class="n">stft_matrix</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">ref_power</span><span class="p">):</span>
        <span class="n">ref_power</span> <span class="o">=</span> <span class="n">ref_power</span><span class="p">(</span><span class="n">mag</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ref_power</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;ref_power must be non-negative or callable.&#39;</span><span class="p">)</span>

    <span class="c1"># Pylint does not correctly infer the type here, but it&#39;s correct.</span>
    <span class="c1"># pylint: disable=maybe-no-member</span>
    <span class="n">freq_angular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">freq_angular</span> <span class="o">=</span> <span class="n">freq_angular</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">bin_offset</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">phase</span> <span class="o">*</span> <span class="n">diff_stft</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">mag</span>
    <span class="n">bin_offset</span><span class="p">[</span><span class="n">mag</span> <span class="o">&lt;</span> <span class="n">ref_power</span><span class="o">**</span><span class="mf">0.5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">if_gram</span> <span class="o">=</span> <span class="n">freq_angular</span><span class="p">[:</span><span class="n">n_fft</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bin_offset</span>

    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="n">stft_matrix</span> <span class="o">*=</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">fft_window</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">if_gram</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">if_gram</span><span class="p">)</span>

    <span class="n">if_gram</span> <span class="o">*=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sr</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="k">return</span> <span class="n">if_gram</span><span class="p">,</span> <span class="n">stft_matrix</span></div>


<span class="k">def</span> <span class="nf">__reassign_frequencies</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Instantaneous frequencies based on a spectrogram representation.</span>

<span class="sd">    The reassignment vector is calculated using equation 5.20 in Flandrin,</span>
<span class="sd">    Auger, &amp; Chassande-Mottin 2002:</span>

<span class="sd">    `omega_reassigned = omega - np.imag(S_dh/S_h)`</span>

<span class="sd">    where `S_h` is the complex STFT calculated using the original window, and</span>
<span class="sd">    `S_dh` is the complex STFT calculated using the derivative of the original</span>
<span class="sd">    window.</span>

<span class="sd">    See `reassigned_spectrogram` for references.</span>

<span class="sd">    It is recommended to use `pad_mode=&quot;wrap&quot;` or else `center=False`, rather</span>
<span class="sd">    than the defaults. Frequency reassignment assumes that the energy in each</span>
<span class="sd">    FFT bin is associated with exactly one signal component. Reflection padding</span>
<span class="sd">    at the edges of the signal may invalidate the reassigned estimates in the</span>
<span class="sd">    boundary frames.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)], real-valued</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) complex STFT calculated using the other arguments provided</span>
<span class="sd">        to `__reassign_frequencies`</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size. Defaults to 2048.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length, number samples between subsequent frames.</span>
<span class="sd">        If not supplied, defaults to `win_length / 4`.</span>

<span class="sd">    win_length : int &gt; 0, &lt;= n_fft</span>
<span class="sd">        Window length. Defaults to `n_fft`.</span>
<span class="sd">        See `stft` for details.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a user-specified window vector of length `n_fft`</span>

<span class="sd">        See `stft` for details.</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `S[:, t]` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then `S[:, t]` begins at `y[t * hop_length]`.</span>

<span class="sd">    dtype : numeric type</span>
<span class="sd">        Complex numeric type for `S`. Default is 64-bit complex.</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    freqs : np.ndarray [shape=(1 + n_fft/2, t), dtype=real]</span>
<span class="sd">        Instantaneous frequencies:</span>
<span class="sd">        `freqs[f, t]` is the frequency for bin `f`, frame `t`.</span>

<span class="sd">    S : np.ndarray [shape=(1 + n_fft/2, t), dtype=complex]</span>
<span class="sd">        Short-time Fourier transform</span>

<span class="sd">    Warns</span>
<span class="sd">    --------</span>
<span class="sd">    RuntimeWarning</span>
<span class="sd">        Frequencies with zero support will produce a divide-by-zero warning and</span>
<span class="sd">        will be returned as `np.nan`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft : Short-time Fourier Transform</span>
<span class="sd">    reassigned_spectrogram : Time-frequency reassigned spectrogram</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; frequencies, S = librosa.core.spectrum.__reassign_frequencies(y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; frequencies</span>
<span class="sd">    array([[  0.000e+00, 0.000e+00, ..., 0.000e+00, 0.000e+00],</span>
<span class="sd">           [  9.863e+00, 9.653e+00, ..., 1.046e+01, 8.072e+01],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.101e+04, 1.101e+04, ..., 1.102e+04, 1.102e+04],</span>
<span class="sd">           [  1.102e+04, 1.102e+04, ..., 1.102e+04, 1.102e+04]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># retrieve window samples if needed so that the window derivative can be</span>
    <span class="c1"># calculated</span>
    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="n">window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">S_h</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">S_h</span> <span class="o">=</span> <span class="n">S</span>

    <span class="c1"># cyclic gradient to correctly handle edges of a periodic window</span>
    <span class="n">window_derivative</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">cyclic_gradient</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>

    <span class="n">S_dh</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window_derivative</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># equation 5.20 of Flandrin, Auger, &amp; Chassande-Mottin 2002</span>
    <span class="c1"># the sign of the correction is reversed in some papers - see Plante,</span>
    <span class="c1"># Meyer, &amp; Ainsworth 1998 pp. 283-284</span>
    <span class="n">correction</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">S_dh</span> <span class="o">/</span> <span class="n">S_h</span><span class="p">)</span>

    <span class="n">freqs</span> <span class="o">=</span> <span class="n">time_frequency</span><span class="o">.</span><span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">correction</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">sr</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">S_h</span>


<span class="k">def</span> <span class="nf">__reassign_times</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Time reassignments based on a spectrogram representation.</span>

<span class="sd">    The reassignment vector is calculated using equation 5.23 in Flandrin,</span>
<span class="sd">    Auger, &amp; Chassande-Mottin 2002:</span>

<span class="sd">    `t_reassigned = t + np.real(S_th/S_h)`</span>

<span class="sd">    where `S_h` is the complex STFT calculated using the original window, and</span>
<span class="sd">    `S_th` is the complex STFT calculated using the original window multiplied</span>
<span class="sd">    by the time offset from the window center.</span>

<span class="sd">    See `reassigned_spectrogram` for references.</span>

<span class="sd">    It is recommended to use `pad_mode=&quot;constant&quot;` (zero padding) or else</span>
<span class="sd">    `center=False`, rather than the defaults. Time reassignment assumes that</span>
<span class="sd">    the energy in each FFT bin is associated with exactly one impulse event.</span>
<span class="sd">    Reflection padding at the edges of the signal may invalidate the reassigned</span>
<span class="sd">    estimates in the boundary frames.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)], real-valued</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) complex STFT calculated using the other arguments provided</span>
<span class="sd">        to `__reassign_times`</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size. Defaults to 2048.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length, number samples between subsequent frames.</span>
<span class="sd">        If not supplied, defaults to `win_length / 4`.</span>

<span class="sd">    win_length : int &gt; 0, &lt;= n_fft</span>
<span class="sd">        Window length. Defaults to `n_fft`.</span>
<span class="sd">        See `stft` for details.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a user-specified window vector of length `n_fft`</span>

<span class="sd">        See `stft` for details.</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `S[:, t]` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then `S[:, t]` begins at `y[t * hop_length]`.</span>

<span class="sd">    dtype : numeric type</span>
<span class="sd">        Complex numeric type for `S`. Default is 64-bit complex.</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    times : np.ndarray [shape=(1 + n_fft/2, t), dtype=real]</span>
<span class="sd">        Reassigned times:</span>
<span class="sd">        `times[f, t]` is the time for bin `f`, frame `t`.</span>

<span class="sd">    S : np.ndarray [shape=(1 + n_fft/2, t), dtype=complex]</span>
<span class="sd">        Short-time Fourier transform</span>

<span class="sd">    Warns</span>
<span class="sd">    --------</span>
<span class="sd">    RuntimeWarning</span>
<span class="sd">        Time estimates with zero support will produce a divide-by-zero warning</span>
<span class="sd">        and will be returned as `np.nan`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft : Short-time Fourier Transform</span>
<span class="sd">    reassigned_spectrogram : Time-frequency reassigned spectrogram</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; times, S = librosa.core.spectrum.__reassign_times(y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; times</span>
<span class="sd">    array([[ 0.077,  0.079,  ..., 61.362, 61.388],</span>
<span class="sd">           [ 0.078,  0.077,  ..., 61.366, 61.538],</span>
<span class="sd">           [ 0.088,  0.08 ,  ..., 61.358, 61.399],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 0.078,  0.077,  ..., 61.378, 61.372],</span>
<span class="sd">           [ 0.082,  0.077,  ..., 61.371, 61.38 ],</span>
<span class="sd">           [ 0.075,  0.076,  ..., 61.374, 61.385]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># retrieve window samples if needed so that the time-weighted window can be</span>
    <span class="c1"># calculated</span>
    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="n">window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">win_length</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># retrieve hop length if needed so that the frame times can be calculated</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">S_h</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">S_h</span> <span class="o">=</span> <span class="n">S</span>

    <span class="c1"># calculate window weighted by time</span>
    <span class="n">half_width</span> <span class="o">=</span> <span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">n_fft</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">window_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">half_width</span><span class="p">,</span> <span class="n">half_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">window_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">-</span> <span class="n">half_width</span><span class="p">,</span> <span class="n">half_width</span><span class="p">)</span>

    <span class="n">window_time_weighted</span> <span class="o">=</span> <span class="n">window</span> <span class="o">*</span> <span class="n">window_times</span>

    <span class="n">S_th</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span>
        <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
        <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="n">window_time_weighted</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># equation 5.23 of Flandrin, Auger, &amp; Chassande-Mottin 2002</span>
    <span class="c1"># the sign of the correction is reversed in some papers - see Plante,</span>
    <span class="c1"># Meyer, &amp; Ainsworth 1998 pp. 283-284</span>
    <span class="n">correction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">S_th</span> <span class="o">/</span> <span class="n">S_h</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="n">pad_length</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">pad_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="n">times</span> <span class="o">=</span> <span class="n">time_frequency</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">S_h</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">pad_length</span>
    <span class="p">)</span>

    <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">correction</span> <span class="o">/</span> <span class="n">sr</span>

    <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S_h</span>


<div class="viewcode-block" id="reassigned_spectrogram"><a class="viewcode-back" href="../../../generated/librosa.core.reassigned_spectrogram.html#librosa.core.reassigned_spectrogram">[docs]</a><span class="k">def</span> <span class="nf">reassigned_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">reassign_frequencies</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reassign_times</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">ref_power</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">fill_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Time-frequency reassigned spectrogram.</span>

<span class="sd">    The reassignment vectors are calculated using equations 5.20 and 5.23 in</span>
<span class="sd">    [1]_:</span>

<span class="sd">        `t_reassigned = t + np.real(S_th/S_h)`</span>
<span class="sd">        `omega_reassigned = omega - np.imag(S_dh/S_h)`</span>

<span class="sd">    where `S_h` is the complex STFT calculated using the original window,</span>
<span class="sd">    `S_dh` is the complex STFT calculated using the derivative of the original</span>
<span class="sd">    window, and `S_th` is the complex STFT calculated using the original window</span>
<span class="sd">    multiplied by the time offset from the window center. See [2]_ for</span>
<span class="sd">    additional algorithms, and [3]_ and [4]_ for history and discussion of the</span>
<span class="sd">    method.</span>

<span class="sd">    .. [1] Flandrin, P., Auger, F., &amp; Chassande-Mottin, E. (2002).</span>
<span class="sd">        Time-Frequency reassignment: From principles to algorithms. In</span>
<span class="sd">        Applications in Time-Frequency Signal Processing (Vol. 10, pp.</span>
<span class="sd">        179-204). CRC Press.</span>

<span class="sd">    .. [2] Fulop, S. A., &amp; Fitz, K. (2006). Algorithms for computing the</span>
<span class="sd">        time-corrected instantaneous frequency (reassigned) spectrogram, with</span>
<span class="sd">        applications. The Journal of the Acoustical Society of America, 119(1),</span>
<span class="sd">        360. doi:10.1121/1.2133000</span>

<span class="sd">    .. [3] Auger, F., Flandrin, P., Lin, Y.-T., McLaughlin, S., Meignen, S.,</span>
<span class="sd">        Oberlin, T., &amp; Wu, H.-T. (2013). Time-Frequency Reassignment and</span>
<span class="sd">        Synchrosqueezing: An Overview. IEEE Signal Processing Magazine, 30(6),</span>
<span class="sd">        32-41. doi:10.1109/MSP.2013.2265316</span>

<span class="sd">    .. [4] Hainsworth, S., Macleod, M. (2003). Time-frequency reassignment: a</span>
<span class="sd">        review and analysis. Tech. Rep. CUED/FINFENG/TR.459, Cambridge</span>
<span class="sd">        University Engineering Department</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)], real-valued</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) complex STFT calculated using the other arguments provided</span>
<span class="sd">        to `reassigned_spectrogram`</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size. Defaults to 2048.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length, number samples between subsequent frames.</span>
<span class="sd">        If not supplied, defaults to `win_length / 4`.</span>

<span class="sd">    win_length : int &gt; 0, &lt;= n_fft</span>
<span class="sd">        Window length. Defaults to `n_fft`.</span>
<span class="sd">        See `stft` for details.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a user-specified window vector of length `n_fft`</span>

<span class="sd">        See `stft` for details.</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True` (default), the signal `y` is padded so that frame</span>
<span class="sd">          `S[:, t]` is centered at `y[t * hop_length]`. See `Notes` for</span>
<span class="sd">          recommended usage in this function.</span>
<span class="sd">        - If `False`, then `S[:, t]` begins at `y[t * hop_length]`.</span>

<span class="sd">    reassign_frequencies : boolean</span>
<span class="sd">        - If `True` (default), the returned frequencies will be instantaneous</span>
<span class="sd">          frequency estimates.</span>
<span class="sd">        - If `False`, the returned frequencies will be a read-only view of the</span>
<span class="sd">          STFT bin frequencies for all frames.</span>

<span class="sd">    reassign_times : boolean</span>
<span class="sd">        - If `True` (default), the returned times will be corrected</span>
<span class="sd">          (reassigned) time estimates for each bin.</span>
<span class="sd">        - If `False`, the returned times will be a read-only view of the STFT</span>
<span class="sd">          frame times for all bins.</span>

<span class="sd">    ref_power : float &gt;= 0 or callable</span>
<span class="sd">        Minimum power threshold for estimating time-frequency reassignments.</span>
<span class="sd">        Any bin with `np.abs(S[f, t])**2 &lt; ref_power` will be returned as</span>
<span class="sd">        `np.nan` in both frequency and time, unless `fill_nan` is `True`. If 0</span>
<span class="sd">        is provided, then only bins with zero power will be returned as</span>
<span class="sd">        `np.nan` (unless `fill_nan=True`).</span>

<span class="sd">    fill_nan : boolean</span>
<span class="sd">        - If `False` (default), the frequency and time reassignments for bins</span>
<span class="sd">          below the power threshold provided in `ref_power` will be returned as</span>
<span class="sd">          `np.nan`.</span>
<span class="sd">        - If `True`, the frequency and time reassignments for these bins will</span>
<span class="sd">          be returned as the bin center frequencies and frame times.</span>

<span class="sd">    clip : boolean</span>
<span class="sd">        - If `True` (default), estimated frequencies outside the range</span>
<span class="sd">          `[0, 0.5 * sr]` or times outside the range `[0, len(y) / sr]` will be</span>
<span class="sd">          clipped to those ranges.</span>
<span class="sd">        - If `False`, estimated frequencies and times beyond the bounds of the</span>
<span class="sd">          spectrogram may be returned.</span>

<span class="sd">    dtype : numeric type</span>
<span class="sd">        Complex numeric type for STFT calculation. Default is 64-bit complex.</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    freqs : np.ndarray [shape=(1 + n_fft/2, t), dtype=real]</span>
<span class="sd">        Instantaneous frequencies:</span>
<span class="sd">        `freqs[f, t]` is the frequency for bin `f`, frame `t`.</span>
<span class="sd">        If `reassign_frequencies=False`, this will instead be a read-only array</span>
<span class="sd">        of the same shape containing the bin center frequencies for all frames.</span>

<span class="sd">    times : np.ndarray [shape=(1 + n_fft/2, t), dtype=real]</span>
<span class="sd">        Reassigned times:</span>
<span class="sd">        `times[f, t]` is the time for bin `f`, frame `t`.</span>
<span class="sd">        If `reassign_times=False`, this will instead be a read-only array of</span>
<span class="sd">        the same shape containing the frame times for all bins.</span>

<span class="sd">    mags : np.ndarray [shape=(1 + n_fft/2, t), dtype=real]</span>
<span class="sd">        Magnitudes from short-time Fourier transform:</span>
<span class="sd">        `mags[f, t]` is the magnitude for bin `f`, frame `t`.</span>

<span class="sd">    Warns</span>
<span class="sd">    --------</span>
<span class="sd">    RuntimeWarning</span>
<span class="sd">        Frequency or time estimates with zero support will produce a</span>
<span class="sd">        divide-by-zero warning, and will be returned as `np.nan` unless</span>
<span class="sd">        `fill_nan=True`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft : Short-time Fourier Transform</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    It is recommended to use `center=False` with this function rather than the</span>
<span class="sd">    librosa default `True`. Unlike `stft`, reassigned times are not aligned to</span>
<span class="sd">    the left or center of each frame, so padding the signal does not affect the</span>
<span class="sd">    meaning of the reassigned times. However, reassignment assumes that the</span>
<span class="sd">    energy in each FFT bin is associated with exactly one signal component and</span>
<span class="sd">    impulse event. The default `center=True` with reflection padding can thus</span>
<span class="sd">    invalidate the reassigned estimates in the half-reflected frames at the</span>
<span class="sd">    beginning and end of the signal.</span>

<span class="sd">    If `reassign_times` is `False`, the frame times that are returned will be</span>
<span class="sd">    aligned to the left or center of the frame, depending on the value of</span>
<span class="sd">    `center`. In this case, if `center` is `True`, then `pad_mode=&quot;wrap&quot;` is</span>
<span class="sd">    recommended for valid estimation of the instantaneous frequencies in the</span>
<span class="sd">    boundary frames.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; amin = 1e-10</span>
<span class="sd">    &gt;&gt;&gt; n_fft = 64</span>
<span class="sd">    &gt;&gt;&gt; sr = 4000</span>
<span class="sd">    &gt;&gt;&gt; y = 1e-3 * librosa.clicks(times=[0.3], sr=sr, click_duration=1.0,</span>
<span class="sd">    ...                           click_freq=1200.0, length=8000) +\</span>
<span class="sd">    ...     1e-3 * librosa.clicks(times=[1.5], sr=sr, click_duration=0.5,</span>
<span class="sd">    ...                           click_freq=400.0, length=8000) +\</span>
<span class="sd">    ...     1e-3 * librosa.chirp(200, 1600, sr=sr, duration=2.0) +\</span>
<span class="sd">    ...     1e-6 * np.random.randn(2*sr)</span>
<span class="sd">    &gt;&gt;&gt; freqs, times, mags = librosa.reassigned_spectrogram(y=y, sr=sr,</span>
<span class="sd">    ...                                                     n_fft=n_fft)</span>
<span class="sd">    &gt;&gt;&gt; mags_db = librosa.power_to_db(mags, amin=amin)</span>
<span class="sd">    &gt;&gt;&gt; ax = plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(mags_db, x_axis=&quot;s&quot;, y_axis=&quot;linear&quot;, sr=sr,</span>
<span class="sd">    ...                          hop_length=n_fft//4, cmap=&quot;gray_r&quot;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Spectrogram&quot;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tick_params(axis=&#39;x&#39;, labelbottom=False)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;&quot;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2, sharex=ax, sharey=ax)</span>
<span class="sd">    &gt;&gt;&gt; plt.scatter(times, freqs, c=mags_db, alpha=0.05, cmap=&quot;gray_r&quot;)</span>
<span class="sd">    &gt;&gt;&gt; plt.clim(10*np.log10(amin), np.max(mags_db))</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Reassigned spectrogram&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">ref_power</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ref_power</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;ref_power must be non-negative or callable.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">reassign_frequencies</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reassign_times</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="s2">&quot;reassign_frequencies or reassign_times must be True.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">win_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_length</span> <span class="o">=</span> <span class="n">n_fft</span>

    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># frequency and time reassignment if requested</span>
    <span class="k">if</span> <span class="n">reassign_frequencies</span><span class="p">:</span>
        <span class="n">freqs</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">__reassign_frequencies</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
            <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">reassign_times</span><span class="p">:</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">__reassign_times</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
            <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="c1"># clean up reassignment issues: divide-by-zero, bins with near-zero power,</span>
    <span class="c1"># and estimates outside the spectrogram bounds</span>

    <span class="c1"># retrieve bin frequencies and frame times to replace missing estimates</span>
    <span class="k">if</span> <span class="n">fill_nan</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">reassign_frequencies</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">reassign_times</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">pad_length</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">pad_length</span> <span class="o">=</span> <span class="n">n_fft</span>

        <span class="n">bin_freqs</span> <span class="o">=</span> <span class="n">time_frequency</span><span class="o">.</span><span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

        <span class="n">frame_times</span> <span class="o">=</span> <span class="n">time_frequency</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span>
            <span class="n">frames</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">pad_length</span>
        <span class="p">)</span>

    <span class="c1"># find bins below the power threshold</span>
    <span class="c1"># reassigned bins with zero power will already be NaN</span>
    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">ref_power</span><span class="p">):</span>
        <span class="n">ref_power</span> <span class="o">=</span> <span class="n">ref_power</span><span class="p">(</span><span class="n">mags</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">mags_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span> <span class="n">ref_power</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">mags</span><span class="p">))</span>

    <span class="c1"># for reassigned estimates, optionally set thresholded bins to NaN, return</span>
    <span class="c1"># bin frequencies and frame times in place of NaN generated by</span>
    <span class="c1"># divide-by-zero and power threshold, and clip to spectrogram bounds</span>
    <span class="k">if</span> <span class="n">reassign_frequencies</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ref_power</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">mags_low</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">fill_nan</span><span class="p">:</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">freqs</span><span class="p">),</span> <span class="n">bin_freqs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">freqs</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sr</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">freqs</span><span class="p">)</span>

    <span class="c1"># or if reassignment was not requested, return bin frequencies and frame</span>
    <span class="c1"># times for every cell is the spectrogram</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">bin_freqs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">reassign_times</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ref_power</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">times</span><span class="p">[</span><span class="n">mags_low</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">fill_nan</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">frame_times</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">times</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sr</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">frame_times</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">mags</span></div>


<div class="viewcode-block" id="magphase"><a class="viewcode-back" href="../../../generated/librosa.core.magphase.html#librosa.core.magphase">[docs]</a><span class="k">def</span> <span class="nf">magphase</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Separate a complex-valued spectrogram D into its magnitude (S)</span>
<span class="sd">    and phase (P) components, so that `D = S * P`.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D : np.ndarray [shape=(d, t), dtype=complex]</span>
<span class="sd">        complex-valued spectrogram</span>
<span class="sd">    power : float &gt; 0</span>
<span class="sd">        Exponent for the magnitude spectrogram,</span>
<span class="sd">        e.g., 1 for energy, 2 for power, etc.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D_mag : np.ndarray [shape=(d, t), dtype=real]</span>
<span class="sd">        magnitude of `D`, raised to `power`</span>
<span class="sd">    D_phase : np.ndarray [shape=(d, t), dtype=complex]</span>
<span class="sd">        `exp(1.j * phi)` where `phi` is the phase of `D`</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; magnitude, phase = librosa.magphase(D)</span>
<span class="sd">    &gt;&gt;&gt; magnitude</span>
<span class="sd">    array([[  2.524e-03,   4.329e-02, ...,   3.217e-04,   3.520e-05],</span>
<span class="sd">           [  2.645e-03,   5.152e-02, ...,   3.283e-04,   3.432e-04],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.966e-05,   9.828e-06, ...,   3.164e-07,   9.370e-06],</span>
<span class="sd">           [  1.966e-05,   9.830e-06, ...,   3.161e-07,   9.366e-06]], dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; phase</span>
<span class="sd">    array([[  1.000e+00 +0.000e+00j,   1.000e+00 +0.000e+00j, ...,</span>
<span class="sd">             -1.000e+00 +8.742e-08j,  -1.000e+00 +8.742e-08j],</span>
<span class="sd">           [  1.000e+00 +1.615e-16j,   9.950e-01 -1.001e-01j, ...,</span>
<span class="sd">              9.794e-01 +2.017e-01j,   1.492e-02 -9.999e-01j],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.000e+00 -5.609e-15j,  -5.081e-04 +1.000e+00j, ...,</span>
<span class="sd">             -9.549e-01 -2.970e-01j,   2.938e-01 -9.559e-01j],</span>
<span class="sd">           [ -1.000e+00 +8.742e-08j,  -1.000e+00 +8.742e-08j, ...,</span>
<span class="sd">             -1.000e+00 +8.742e-08j,  -1.000e+00 +8.742e-08j]], dtype=complex64)</span>


<span class="sd">    Or get the phase angle (in radians)</span>

<span class="sd">    &gt;&gt;&gt; np.angle(phase)</span>
<span class="sd">    array([[  0.000e+00,   0.000e+00, ...,   3.142e+00,   3.142e+00],</span>
<span class="sd">           [  1.615e-16,  -1.003e-01, ...,   2.031e-01,  -1.556e+00],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ -5.609e-15,   1.571e+00, ...,  -2.840e+00,  -1.273e+00],</span>
<span class="sd">           [  3.142e+00,   3.142e+00, ...,   3.142e+00,   3.142e+00]], dtype=float32)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
    <span class="n">mag</span> <span class="o">**=</span> <span class="n">power</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">mag</span><span class="p">,</span> <span class="n">phase</span></div>


<div class="viewcode-block" id="phase_vocoder"><a class="viewcode-back" href="../../../generated/librosa.core.phase_vocoder.html#librosa.core.phase_vocoder">[docs]</a><span class="k">def</span> <span class="nf">phase_vocoder</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Phase vocoder.  Given an STFT matrix D, speed up by a factor of `rate`</span>

<span class="sd">    Based on the implementation provided by [1]_.</span>

<span class="sd">    .. note:: This is a simplified implementation, intended primarily for</span>
<span class="sd">             reference and pedagogical purposes.  It makes no attempt to</span>
<span class="sd">             handle transients, and is likely to produce many audible</span>
<span class="sd">             artifacts.  For a higher quality implementation, we recommend</span>
<span class="sd">             the RubberBand library [2]_ and its Python wrapper `pyrubberband`.</span>

<span class="sd">    .. [1] Ellis, D. P. W. &quot;A phase vocoder in Matlab.&quot;</span>
<span class="sd">        Columbia University, 2002.</span>
<span class="sd">        http://www.ee.columbia.edu/~dpwe/resources/matlab/pvoc/</span>

<span class="sd">    .. [2] https://breakfastquay.com/rubberband/</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Play at double speed</span>
<span class="sd">    &gt;&gt;&gt; y, sr   = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D       = librosa.stft(y, n_fft=2048, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; D_fast  = librosa.phase_vocoder(D, 2.0, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; y_fast  = librosa.istft(D_fast, hop_length=512)</span>

<span class="sd">    &gt;&gt;&gt; # Or play at 1/3 speed</span>
<span class="sd">    &gt;&gt;&gt; y, sr   = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D       = librosa.stft(y, n_fft=2048, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; D_slow  = librosa.phase_vocoder(D, 1./3, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; y_slow  = librosa.istft(D_slow, hop_length=512)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D : np.ndarray [shape=(d, t), dtype=complex]</span>
<span class="sd">        STFT matrix</span>

<span class="sd">    rate :  float &gt; 0 [scalar]</span>
<span class="sd">        Speed-up factor: `rate &gt; 1` is faster, `rate &lt; 1` is slower.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar] or None</span>
<span class="sd">        The number of samples between successive columns of `D`.</span>

<span class="sd">        If None, defaults to `n_fft/4 = (D.shape[0]-1)/2`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D_stretched : np.ndarray [shape=(d, t / rate), dtype=complex]</span>
<span class="sd">        time-stretched STFT</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    pyrubberband</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="n">time_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rate</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="c1"># Create an empty output array</span>
    <span class="n">d_stretch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_steps</span><span class="p">)),</span> <span class="n">D</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="c1"># Expected phase advance in each bin</span>
    <span class="n">phi_advance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">hop_length</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Phase accumulator; initialize to the first sample</span>
    <span class="n">phase_acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Pad 0 columns to simplify boundary logic</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_steps</span><span class="p">):</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="n">D</span><span class="p">[:,</span> <span class="nb">int</span><span class="p">(</span><span class="n">step</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="n">step</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span>

        <span class="c1"># Weighting for linear magnitude interpolation</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">columns</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
               <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">columns</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Store to output array</span>
        <span class="n">d_stretch</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">mag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_acc</span><span class="p">)</span>

        <span class="c1"># Compute phase advance</span>
        <span class="n">dphase</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">columns</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                  <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">columns</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                  <span class="o">-</span> <span class="n">phi_advance</span><span class="p">)</span>

        <span class="c1"># Wrap to -pi:pi range</span>
        <span class="n">dphase</span> <span class="o">=</span> <span class="n">dphase</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">dphase</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>

        <span class="c1"># Accumulate phase</span>
        <span class="n">phase_acc</span> <span class="o">+=</span> <span class="n">phi_advance</span> <span class="o">+</span> <span class="n">dphase</span>

    <span class="k">return</span> <span class="n">d_stretch</span></div>


<div class="viewcode-block" id="iirt"><a class="viewcode-back" href="../../../generated/librosa.core.iirt.html#librosa.core.iirt">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">iirt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
         <span class="n">tuning</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="n">flayout</span><span class="o">=</span><span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Time-frequency representation using IIR filters [1]_.</span>

<span class="sd">    This function will return a time-frequency representation</span>
<span class="sd">    using a multirate filter bank consisting of IIR filters.</span>
<span class="sd">    First, `y` is resampled as needed according to the provided `sample_rates`.</span>
<span class="sd">    Then, a filterbank with with `n` band-pass filters is designed.</span>
<span class="sd">    The resampled input signals are processed by the filterbank as a whole.</span>
<span class="sd">    (`scipy.signal.filtfilt` resp. `sosfiltfilt` is used to make the phase linear.)</span>
<span class="sd">    The output of the filterbank is cut into frames.</span>
<span class="sd">    For each band, the short-time mean-square power (STMSP) is calculated by</span>
<span class="sd">    summing `win_length` subsequent filtered time samples.</span>

<span class="sd">    When called with the default set of parameters, it will generate the TF-representation</span>
<span class="sd">    as described in [1]_ (pitch filterbank):</span>

<span class="sd">        * 85 filters with MIDI pitches [24, 108] as `center_freqs`.</span>
<span class="sd">        * each filter having a bandwith of one semitone.</span>

<span class="sd">    .. [1] Müller, Meinard.</span>
<span class="sd">           &quot;Information Retrieval for Music and Motion.&quot;</span>
<span class="sd">           Springer Verlag. 2007.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    win_length : int &gt; 0, &lt;= n_fft</span>
<span class="sd">        Window length.</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        Hop length, number samples between subsequent frames.</span>
<span class="sd">        If not supplied, defaults to `win_length / 4`.</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `D[:, t]` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then `D[:, t]` begins at `y[t * hop_length]`</span>

<span class="sd">    tuning : float [scalar]</span>
<span class="sd">        Tuning deviation from A440 in fractions of a bin.</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, this function uses reflection padding.</span>

<span class="sd">    flayout : string</span>
<span class="sd">        - If `sos` (default), a series of second-order filters is used for filtering with `scipy.signal.sosfiltfilt`.</span>
<span class="sd">          Minimizes numerical precision errors for high-order filters, but is slower.</span>
<span class="sd">        - If `ba`, the standard difference equation is used for filtering with `scipy.signal.filtfilt`.</span>
<span class="sd">          Can be unstable for high-order filters.</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">        Additional arguments for `librosa.filters.semitone_filterbank()`</span>
<span class="sd">        (e.g., could be used to provide another set of `center_freqs` and `sample_rates`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bands_power : np.ndarray [shape=(n, t), dtype=dtype]</span>
<span class="sd">        Short-time mean-square power for the input signal.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If `flayout` is not None, `ba`, or `sos`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.filters.semitone_filterbank</span>
<span class="sd">    librosa.filters._multirate_fb</span>
<span class="sd">    librosa.filters.mr_frequencies</span>
<span class="sd">    librosa.core.cqt</span>
<span class="sd">    scipy.signal.filtfilt</span>
<span class="sd">    scipy.signal.sosfiltfilt</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; D = np.abs(librosa.iirt(y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(D, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;cqt_hz&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Semitone spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">flayout</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ba&#39;</span><span class="p">,</span> <span class="s1">&#39;sos&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Unsupported flayout=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">flayout</span><span class="p">))</span>

    <span class="c1"># check audio input</span>
    <span class="n">util</span><span class="o">.</span><span class="n">valid_audio</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># Set the default hop, if it&#39;s not already specified</span>
    <span class="k">if</span> <span class="n">hop_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hop_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Pad the time series so that frames are centered</span>
    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">hop_length</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

    <span class="c1"># get the semitone filterbank</span>
    <span class="n">filterbank_ct</span><span class="p">,</span> <span class="n">sample_rates</span> <span class="o">=</span> <span class="n">semitone_filterbank</span><span class="p">(</span><span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">,</span> <span class="n">flayout</span><span class="o">=</span><span class="n">flayout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># create three downsampled versions of the audio signal</span>
    <span class="n">y_resampled</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">y_srs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sample_rates</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">cur_sr</span> <span class="ow">in</span> <span class="n">y_srs</span><span class="p">:</span>
        <span class="n">y_resampled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resample</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">cur_sr</span><span class="p">))</span>

    <span class="c1"># Compute the number of frames that will fit. The end may get truncated.</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">win_length</span><span class="p">)</span> <span class="o">//</span> <span class="nb">float</span><span class="p">(</span><span class="n">hop_length</span><span class="p">))</span>

    <span class="n">bands_power</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">cur_sr</span><span class="p">,</span> <span class="n">cur_filter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sample_rates</span><span class="p">,</span> <span class="n">filterbank_ct</span><span class="p">):</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sr</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">cur_sr</span><span class="p">)</span>
        <span class="n">win_length_STMSP</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">win_length</span> <span class="o">/</span> <span class="n">factor</span><span class="p">))</span>
        <span class="n">hop_length_STMSP</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">hop_length</span> <span class="o">/</span> <span class="n">factor</span><span class="p">))</span>

        <span class="c1"># filter the signal</span>
        <span class="n">cur_sr_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">y_srs</span> <span class="o">==</span> <span class="n">cur_sr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">flayout</span> <span class="o">==</span> <span class="s1">&#39;ba&#39;</span><span class="p">:</span>
            <span class="n">cur_filter_output</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">cur_filter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur_filter</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                      <span class="n">y_resampled</span><span class="p">[</span><span class="n">cur_sr_idx</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">flayout</span> <span class="o">==</span> <span class="s1">&#39;sos&#39;</span><span class="p">:</span>
            <span class="n">cur_filter_output</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">cur_filter</span><span class="p">,</span>
                                                         <span class="n">y_resampled</span><span class="p">[</span><span class="n">cur_sr_idx</span><span class="p">])</span>

        <span class="c1"># frame the current filter output</span>
        <span class="n">cur_frames</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">cur_filter_output</span><span class="p">),</span>
                                <span class="n">frame_length</span><span class="o">=</span><span class="n">win_length_STMSP</span><span class="p">,</span>
                                <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length_STMSP</span><span class="p">)</span>

        <span class="n">bands_power</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cur_frames</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="n">n_frames</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">bands_power</span><span class="p">)</span></div>


<div class="viewcode-block" id="power_to_db"><a class="viewcode-back" href="../../../generated/librosa.core.power_to_db.html#librosa.core.power_to_db">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">amin</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">top_db</span><span class="o">=</span><span class="mf">80.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a power spectrogram (amplitude squared) to decibel (dB) units</span>

<span class="sd">    This computes the scaling ``10 * log10(S / ref)`` in a numerically</span>
<span class="sd">    stable way.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        input power</span>

<span class="sd">    ref : scalar or callable</span>
<span class="sd">        If scalar, the amplitude `abs(S)` is scaled relative to `ref`:</span>
<span class="sd">        `10 * log10(S / ref)`.</span>
<span class="sd">        Zeros in the output correspond to positions where `S == ref`.</span>

<span class="sd">        If callable, the reference value is computed as `ref(S)`.</span>

<span class="sd">    amin : float &gt; 0 [scalar]</span>
<span class="sd">        minimum threshold for `abs(S)` and `ref`</span>

<span class="sd">    top_db : float &gt;= 0 [scalar]</span>
<span class="sd">        threshold the output at `top_db` below the peak:</span>
<span class="sd">        ``max(10 * log10(S)) - top_db``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_db : np.ndarray</span>
<span class="sd">        ``S_db ~= 10 * log10(S) - 10 * log10(ref)``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    perceptual_weighting</span>
<span class="sd">    db_to_power</span>
<span class="sd">    amplitude_to_db</span>
<span class="sd">    db_to_amplitude</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get a power spectrogram from a waveform ``y``</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.power_to_db(S**2)</span>
<span class="sd">    array([[-33.293, -27.32 , ..., -33.293, -33.293],</span>
<span class="sd">           [-33.293, -25.723, ..., -33.293, -33.293],</span>
<span class="sd">           ...,</span>
<span class="sd">           [-33.293, -33.293, ..., -33.293, -33.293],</span>
<span class="sd">           [-33.293, -33.293, ..., -33.293, -33.293]], dtype=float32)</span>

<span class="sd">    Compute dB relative to peak power</span>

<span class="sd">    &gt;&gt;&gt; librosa.power_to_db(S**2, ref=np.max)</span>
<span class="sd">    array([[-80.   , -74.027, ..., -80.   , -80.   ],</span>
<span class="sd">           [-80.   , -72.431, ..., -80.   , -80.   ],</span>
<span class="sd">           ...,</span>
<span class="sd">           [-80.   , -80.   , ..., -80.   , -80.   ],</span>
<span class="sd">           [-80.   , -80.   , ..., -80.   , -80.   ]], dtype=float32)</span>


<span class="sd">    Or compare to median power</span>

<span class="sd">    &gt;&gt;&gt; librosa.power_to_db(S**2, ref=np.median)</span>
<span class="sd">    array([[-0.189,  5.784, ..., -0.189, -0.189],</span>
<span class="sd">           [-0.189,  7.381, ..., -0.189, -0.189],</span>
<span class="sd">           ...,</span>
<span class="sd">           [-0.189, -0.189, ..., -0.189, -0.189],</span>
<span class="sd">           [-0.189, -0.189, ..., -0.189, -0.189]], dtype=float32)</span>


<span class="sd">    And plot the results</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(S**2, sr=sr, y_axis=&#39;log&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.power_to_db(S**2, ref=np.max),</span>
<span class="sd">    ...                          sr=sr, y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Log-Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">amin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;amin must be strictly positive&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;power_to_db was called on complex input so phase &#39;</span>
                      <span class="s1">&#39;information will be discarded. To suppress this warning, &#39;</span>
                      <span class="s1">&#39;call power_to_db(np.abs(D)**2) instead.&#39;</span><span class="p">)</span>
        <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">magnitude</span> <span class="o">=</span> <span class="n">S</span>

    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
        <span class="c1"># User supplied a function to calculate reference power</span>
        <span class="n">ref_value</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">magnitude</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ref_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

    <span class="n">log_spec</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">amin</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">))</span>
    <span class="n">log_spec</span> <span class="o">-=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">amin</span><span class="p">,</span> <span class="n">ref_value</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">top_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">top_db</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;top_db must be non-negative&#39;</span><span class="p">)</span>
        <span class="n">log_spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">log_spec</span><span class="p">,</span> <span class="n">log_spec</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">top_db</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">log_spec</span></div>


<div class="viewcode-block" id="db_to_power"><a class="viewcode-back" href="../../../generated/librosa.core.db_to_power.html#librosa.core.db_to_power">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">db_to_power</span><span class="p">(</span><span class="n">S_db</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Convert a dB-scale spectrogram to a power spectrogram.</span>

<span class="sd">    This effectively inverts `power_to_db`:</span>

<span class="sd">        `db_to_power(S_db) ~= ref * 10.0**(S_db / 10)`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S_db : np.ndarray</span>
<span class="sd">        dB-scaled spectrogram</span>

<span class="sd">    ref : number &gt; 0</span>
<span class="sd">        Reference power: output will be scaled by this value</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        Power spectrogram</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">ref</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">S_db</span><span class="p">)</span></div>


<div class="viewcode-block" id="amplitude_to_db"><a class="viewcode-back" href="../../../generated/librosa.core.amplitude_to_db.html#librosa.core.amplitude_to_db">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">amplitude_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">amin</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">top_db</span><span class="o">=</span><span class="mf">80.0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Convert an amplitude spectrogram to dB-scaled spectrogram.</span>

<span class="sd">    This is equivalent to ``power_to_db(S**2)``, but is provided for convenience.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        input amplitude</span>

<span class="sd">    ref : scalar or callable</span>
<span class="sd">        If scalar, the amplitude `abs(S)` is scaled relative to `ref`:</span>
<span class="sd">        `20 * log10(S / ref)`.</span>
<span class="sd">        Zeros in the output correspond to positions where `S == ref`.</span>

<span class="sd">        If callable, the reference value is computed as `ref(S)`.</span>

<span class="sd">    amin : float &gt; 0 [scalar]</span>
<span class="sd">        minimum threshold for `S` and `ref`</span>

<span class="sd">    top_db : float &gt;= 0 [scalar]</span>
<span class="sd">        threshold the output at `top_db` below the peak:</span>
<span class="sd">        ``max(20 * log10(S)) - top_db``</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_db : np.ndarray</span>
<span class="sd">        ``S`` measured in dB</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    power_to_db, db_to_amplitude</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;amplitude_to_db was called on complex input so phase &#39;</span>
                      <span class="s1">&#39;information will be discarded. To suppress this warning, &#39;</span>
                      <span class="s1">&#39;call amplitude_to_db(np.abs(S)) instead.&#39;</span><span class="p">)</span>

    <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
        <span class="c1"># User supplied a function to calculate reference power</span>
        <span class="n">ref_value</span> <span class="o">=</span> <span class="n">ref</span><span class="p">(</span><span class="n">magnitude</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ref_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

    <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">magnitude</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">magnitude</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">ref_value</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">amin</span><span class="o">=</span><span class="n">amin</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                       <span class="n">top_db</span><span class="o">=</span><span class="n">top_db</span><span class="p">)</span></div>


<div class="viewcode-block" id="db_to_amplitude"><a class="viewcode-back" href="../../../generated/librosa.core.db_to_amplitude.html#librosa.core.db_to_amplitude">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">db_to_amplitude</span><span class="p">(</span><span class="n">S_db</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Convert a dB-scaled spectrogram to an amplitude spectrogram.</span>

<span class="sd">    This effectively inverts `amplitude_to_db`:</span>

<span class="sd">        `db_to_amplitude(S_db) ~= 10.0**(0.5 * (S_db + log10(ref)/10))`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S_db : np.ndarray</span>
<span class="sd">        dB-scaled spectrogram</span>

<span class="sd">    ref: number &gt; 0</span>
<span class="sd">        Optional reference power.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        Linear magnitude spectrogram</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">db_to_power</span><span class="p">(</span><span class="n">S_db</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">ref</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span></div>


<div class="viewcode-block" id="perceptual_weighting"><a class="viewcode-back" href="../../../generated/librosa.core.perceptual_weighting.html#librosa.core.perceptual_weighting">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">perceptual_weighting</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Perceptual weighting of a power spectrogram:</span>

<span class="sd">    `S_p[f] = A_weighting(f) + 10*log(S[f] / ref)`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray [shape=(d, t)]</span>
<span class="sd">        Power spectrogram</span>

<span class="sd">    frequencies : np.ndarray [shape=(d,)]</span>
<span class="sd">        Center frequency for each row of `S`</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">        Additional keyword arguments to `power_to_db`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_p : np.ndarray [shape=(d, t)]</span>
<span class="sd">        perceptually weighted version of `S`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    power_to_db</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Re-weight a CQT power spectrum, using peak power as reference</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; C = np.abs(librosa.cqt(y, sr=sr, fmin=librosa.note_to_hz(&#39;A1&#39;)))</span>
<span class="sd">    &gt;&gt;&gt; freqs = librosa.cqt_frequencies(C.shape[0],</span>
<span class="sd">    ...                                 fmin=librosa.note_to_hz(&#39;A1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; perceptual_CQT = librosa.perceptual_weighting(C**2,</span>
<span class="sd">    ...                                               freqs,</span>
<span class="sd">    ...                                               ref=np.max)</span>
<span class="sd">    &gt;&gt;&gt; perceptual_CQT</span>
<span class="sd">    array([[ -80.076,  -80.049, ..., -104.735, -104.735],</span>
<span class="sd">           [ -78.344,  -78.555, ..., -103.725, -103.725],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ -76.272,  -76.272, ...,  -76.272,  -76.272],</span>
<span class="sd">           [ -76.485,  -76.485, ...,  -76.485,  -76.485]])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(C,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          fmin=librosa.note_to_hz(&#39;A1&#39;),</span>
<span class="sd">    ...                          y_axis=&#39;cqt_hz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Log CQT power&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(perceptual_CQT, y_axis=&#39;cqt_hz&#39;,</span>
<span class="sd">    ...                          fmin=librosa.note_to_hz(&#39;A1&#39;),</span>
<span class="sd">    ...                          x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Perceptually weighted log CQT&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="n">time_frequency</span><span class="o">.</span><span class="n">A_weighting</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="fmt"><a class="viewcode-back" href="../../../generated/librosa.core.fmt.html#librosa.core.fmt">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fmt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">n_fmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">over_sample</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The fast Mellin transform (FMT) [1]_ of a uniformly sampled signal y.</span>

<span class="sd">    When the Mellin parameter (beta) is 1/2, it is also known as the scale transform [2]_.</span>
<span class="sd">    The scale transform can be useful for audio analysis because its magnitude is invariant</span>
<span class="sd">    to scaling of the domain (e.g., time stretching or compression).  This is analogous</span>
<span class="sd">    to the magnitude of the Fourier transform being invariant to shifts in the input domain.</span>


<span class="sd">    .. [1] De Sena, Antonio, and Davide Rocchesso.</span>
<span class="sd">        &quot;A fast Mellin and scale transform.&quot;</span>
<span class="sd">        EURASIP Journal on Applied Signal Processing 2007.1 (2007): 75-75.</span>

<span class="sd">    .. [2] Cohen, L.</span>
<span class="sd">        &quot;The scale representation.&quot;</span>
<span class="sd">        IEEE Transactions on Signal Processing 41, no. 12 (1993): 3275-3292.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray, real-valued</span>
<span class="sd">        The input signal(s).  Can be multidimensional.</span>
<span class="sd">        The target axis must contain at least 3 samples.</span>

<span class="sd">    t_min : float &gt; 0</span>
<span class="sd">        The minimum time spacing (in samples).</span>
<span class="sd">        This value should generally be less than 1 to preserve as much information as</span>
<span class="sd">        possible.</span>

<span class="sd">    n_fmt : int &gt; 2 or None</span>
<span class="sd">        The number of scale transform bins to use.</span>
<span class="sd">        If None, then `n_bins = over_sample * ceil(n * log((n-1)/t_min))` is taken,</span>
<span class="sd">        where `n = y.shape[axis]`</span>

<span class="sd">    kind : str</span>
<span class="sd">        The type of interpolation to use when re-sampling the input.</span>
<span class="sd">        See `scipy.interpolate.interp1d` for possible values.</span>

<span class="sd">        Note that the default is to use high-precision (cubic) interpolation.</span>
<span class="sd">        This can be slow in practice; if speed is preferred over accuracy,</span>
<span class="sd">        then consider using `kind=&#39;linear&#39;`.</span>

<span class="sd">    beta : float</span>
<span class="sd">        The Mellin parameter.  `beta=0.5` provides the scale transform.</span>

<span class="sd">    over_sample : float &gt;= 1</span>
<span class="sd">        Over-sampling factor for exponential resampling.</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to transform `y`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_scale : np.ndarray [dtype=complex]</span>
<span class="sd">        The scale transform of `y` along the `axis` dimension.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        if `n_fmt &lt; 2` or `t_min &lt;= 0`</span>
<span class="sd">        or if `y` is not finite</span>
<span class="sd">        or if `y.shape[axis] &lt; 3`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Generate a signal and time-stretch it (with energy normalization)</span>
<span class="sd">    &gt;&gt;&gt; scale = 1.25</span>
<span class="sd">    &gt;&gt;&gt; freq = 3.0</span>
<span class="sd">    &gt;&gt;&gt; x1 = np.linspace(0, 1, num=1024, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; x2 = np.linspace(0, 1, num=scale * len(x1), endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; y1 = np.sin(2 * np.pi * freq * x1)</span>
<span class="sd">    &gt;&gt;&gt; y2 = np.sin(2 * np.pi * freq * x2) / np.sqrt(scale)</span>
<span class="sd">    &gt;&gt;&gt; # Verify that the two signals have the same energy</span>
<span class="sd">    &gt;&gt;&gt; np.sum(np.abs(y1)**2), np.sum(np.abs(y2)**2)</span>
<span class="sd">        (255.99999999999997, 255.99999999999969)</span>
<span class="sd">    &gt;&gt;&gt; scale1 = librosa.fmt(y1, n_fmt=512)</span>
<span class="sd">    &gt;&gt;&gt; scale2 = librosa.fmt(y2, n_fmt=512)</span>
<span class="sd">    &gt;&gt;&gt; # And plot the results</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(8, 4))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(y1, label=&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(y2, linestyle=&#39;--&#39;, label=&#39;Stretched&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;time (samples)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Input signals&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(np.abs(scale1), label=&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(np.abs(scale2), linestyle=&#39;--&#39;, label=&#39;Stretched&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;scale coefficients&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Scale transform magnitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; # Plot the scale transform of an onset strength autocorrelation</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(),</span>
<span class="sd">    ...                      offset=10.0, duration=30.0)</span>
<span class="sd">    &gt;&gt;&gt; odf = librosa.onset.onset_strength(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; # Auto-correlate with up to 10 seconds lag</span>
<span class="sd">    &gt;&gt;&gt; odf_ac = librosa.autocorrelate(odf, max_size=10 * sr // 512)</span>
<span class="sd">    &gt;&gt;&gt; # Normalize</span>
<span class="sd">    &gt;&gt;&gt; odf_ac = librosa.util.normalize(odf_ac, norm=np.inf)</span>
<span class="sd">    &gt;&gt;&gt; # Compute the scale transform</span>
<span class="sd">    &gt;&gt;&gt; odf_ac_scale = librosa.fmt(librosa.util.normalize(odf_ac), n_fmt=512)</span>
<span class="sd">    &gt;&gt;&gt; # Plot the results</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(odf, label=&#39;Onset strength&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Time (frames)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(odf_ac, label=&#39;Onset autocorrelation&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Lag (frames)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 3)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(np.abs(odf_ac_scale), label=&#39;Scale transform magnitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;scale coefficients&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;y.shape[</span><span class="si">{:}</span><span class="s1">]==</span><span class="si">{:}</span><span class="s1"> &lt; 3&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">t_min</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;t_min must be a positive number&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_fmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">over_sample</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;over_sample must be &gt;= 1&#39;</span><span class="p">)</span>

        <span class="c1"># The base is the maximum ratio between adjacent samples</span>
        <span class="c1"># Since the sample spacing is increasing, this is simply the</span>
        <span class="c1"># ratio between the positions of the last two samples: (n-1)/(n-2)</span>
        <span class="n">log_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">n_fmt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">over_sample</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">t_min</span><span class="p">))</span> <span class="o">/</span> <span class="n">log_base</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">n_fmt</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;n_fmt==</span><span class="si">{:}</span><span class="s1"> &lt; 3&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_fmt</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n_fmt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n_fmt</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">over_sample</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;y must be finite everywhere&#39;</span><span class="p">)</span>

    <span class="n">base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_base</span><span class="p">)</span>
    <span class="c1"># original grid: signal covers [0, 1).  This range is arbitrary, but convenient.</span>
    <span class="c1"># The final sample is positioned at (n-1)/n, so we omit the endpoint</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># build the interpolator</span>
    <span class="n">f_interp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># build the new sampling grid</span>
    <span class="c1"># exponentially spaced between t_min/n and 1 (exclusive)</span>
    <span class="c1"># we&#39;ll go one past where we need, and drop the last sample</span>
    <span class="c1"># When over-sampling, the last input sample contributions n_over samples.</span>
    <span class="c1"># To keep the spacing consistent, we over-sample by n_over, and then</span>
    <span class="c1"># trim the final samples.</span>
    <span class="n">n_over</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">over_sample</span><span class="p">))</span>
    <span class="n">x_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">t_min</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">log_base</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="n">num</span><span class="o">=</span><span class="n">n_fmt</span> <span class="o">+</span> <span class="n">n_over</span><span class="p">,</span>
                        <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)[:</span><span class="o">-</span><span class="n">n_over</span><span class="p">]</span>

    <span class="c1"># Clean up any rounding errors at the boundaries of the interpolation</span>
    <span class="c1"># The interpolator gets angry if we try to extrapolate, so clipping is necessary here.</span>
    <span class="k">if</span> <span class="n">x_exp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t_min</span> <span class="ow">or</span> <span class="n">x_exp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">x_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x_exp</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">t_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Make sure that all sample points are unique</span>
    <span class="c1"># This should never happen!</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x_exp</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_exp</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Redundant sample positions in Mellin transform&#39;</span><span class="p">)</span>

    <span class="c1"># Resample the signal</span>
    <span class="n">y_res</span> <span class="o">=</span> <span class="n">f_interp</span><span class="p">(</span><span class="n">x_exp</span><span class="p">)</span>

    <span class="c1"># Broadcast the window correctly</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y_res</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Apply the window and fft</span>
    <span class="c1"># Normalization is absorbed into the window here for expedience</span>
    <span class="n">fft</span> <span class="o">=</span> <span class="n">get_fftlib</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">y_res</span> <span class="o">*</span> <span class="p">((</span><span class="n">x_exp</span><span class="o">**</span><span class="n">beta</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_fmt</span><span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="pcen"><a class="viewcode-back" href="../../../generated/librosa.core.pcen.html#librosa.core.pcen">[docs]</a><span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">pcen</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mf">0.98</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
         <span class="n">time_constant</span><span class="o">=</span><span class="mf">0.400</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_zf</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Per-channel energy normalization (PCEN) [1]_</span>

<span class="sd">    This function normalizes a time-frequency representation `S` by</span>
<span class="sd">    performing automatic gain control, followed by nonlinear compression:</span>

<span class="sd">        P[f, t] = (S / (eps + M[f, t])**gain + bias)**power - bias**power</span>

<span class="sd">    IMPORTANT: the default values of eps, gain, bias, and power match the</span>
<span class="sd">    original publication [1]_, in which M is a 40-band mel-frequency</span>
<span class="sd">    spectrogram with 25 ms windowing, 10 ms frame shift, and raw audio values</span>
<span class="sd">    in the interval [-2**31; 2**31-1[. If you use these default values, we</span>
<span class="sd">    recommend to make sure that the raw audio is properly scaled to this</span>
<span class="sd">    interval, and not to [-1, 1[ as is most often the case.</span>

<span class="sd">    The matrix `M` is the result of applying a low-pass, temporal IIR filter</span>
<span class="sd">    to `S`:</span>

<span class="sd">        M[f, t] = (1 - b) * M[f, t - 1] + b * S[f, t]</span>

<span class="sd">    If `b` is not provided, it is calculated as:</span>

<span class="sd">        b = (sqrt(1 + 4* T**2) - 1) / (2 * T**2)</span>

<span class="sd">    where `T = time_constant * sr / hop_length`, as in [2]_.</span>

<span class="sd">    This normalization is designed to suppress background noise and</span>
<span class="sd">    emphasize foreground signals, and can be used as an alternative to</span>
<span class="sd">    decibel scaling (`amplitude_to_db`).</span>

<span class="sd">    This implementation also supports smoothing across frequency bins</span>
<span class="sd">    by specifying `max_size &gt; 1`.  If this option is used, the filtered</span>
<span class="sd">    spectrogram `M` is computed as</span>

<span class="sd">        M[f, t] = (1 - b) * M[f, t - 1] + b * R[f, t]</span>

<span class="sd">    where `R` has been max-filtered along the frequency axis, similar to</span>
<span class="sd">    the SuperFlux algorithm implemented in `onset.onset_strength`:</span>

<span class="sd">        R[f, t] = max(S[f - max_size//2: f + max_size//2, t])</span>

<span class="sd">    This can be used to perform automatic gain control on signals that cross</span>
<span class="sd">    or span multiple frequency bans, which may be desirable for spectrograms</span>
<span class="sd">    with high frequency resolution.</span>

<span class="sd">    .. [1] Wang, Y., Getreuer, P., Hughes, T., Lyon, R. F., &amp; Saurous, R. A.</span>
<span class="sd">       (2017, March). Trainable frontend for robust and far-field keyword spotting.</span>
<span class="sd">       In Acoustics, Speech and Signal Processing (ICASSP), 2017</span>
<span class="sd">       IEEE International Conference on (pp. 5670-5674). IEEE.</span>

<span class="sd">    .. [2] Lostanlen, V., Salamon, J., McFee, B., Cartwright, M., Farnsworth, A.,</span>
<span class="sd">       Kelling, S., and Bello, J. P. Per-Channel Energy Normalization: Why and How.</span>
<span class="sd">       IEEE Signal Processing Letters, 26(1), 39-43.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray (non-negative)</span>
<span class="sd">        The input (magnitude) spectrogram</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        The audio sampling rate</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        The hop length of `S`, expressed in samples</span>

<span class="sd">    gain : number &gt;= 0 [scalar]</span>
<span class="sd">        The gain factor.  Typical values should be slightly less than 1.</span>

<span class="sd">    bias : number &gt;= 0 [scalar]</span>
<span class="sd">        The bias point of the nonlinear compression (default: 2)</span>

<span class="sd">    power : number &gt;= 0 [scalar]</span>
<span class="sd">        The compression exponent.  Typical values should be between 0 and 0.5.</span>
<span class="sd">        Smaller values of `power` result in stronger compression.</span>
<span class="sd">        At the limit `power=0`, polynomial compression becomes logarithmic.</span>

<span class="sd">    time_constant : number &gt; 0 [scalar]</span>
<span class="sd">        The time constant for IIR filtering, measured in seconds.</span>

<span class="sd">    eps : number &gt; 0 [scalar]</span>
<span class="sd">        A small constant used to ensure numerical stability of the filter.</span>

<span class="sd">    b : number in [0, 1]  [scalar]</span>
<span class="sd">        The filter coefficient for the low-pass filter.</span>
<span class="sd">        If not provided, it will be inferred from `time_constant`.</span>

<span class="sd">    max_size : int &gt; 0 [scalar]</span>
<span class="sd">        The width of the max filter applied to the frequency axis.</span>
<span class="sd">        If left as `1`, no filtering is performed.</span>

<span class="sd">    ref : None or np.ndarray (shape=S.shape)</span>
<span class="sd">        An optional pre-computed reference spectrum (`R` in the above).</span>
<span class="sd">        If not provided it will be computed from `S`.</span>

<span class="sd">    axis : int [scalar]</span>
<span class="sd">        The (time) axis of the input spectrogram.</span>

<span class="sd">    max_axis : None or int [scalar]</span>
<span class="sd">        The frequency axis of the input spectrogram.</span>
<span class="sd">        If `None`, and `S` is two-dimensional, it will be inferred</span>
<span class="sd">        as the opposite from `axis`.</span>
<span class="sd">        If `S` is not two-dimensional, and `max_size &gt; 1`, an error</span>
<span class="sd">        will be raised.</span>

<span class="sd">    zi : np.ndarray</span>
<span class="sd">        The initial filter delay values.</span>

<span class="sd">        This may be the `zf` (final delay values) of a previous call to `pcen`, or</span>
<span class="sd">        computed by `scipy.signal.lfilter_zi`.</span>

<span class="sd">    return_zf : bool</span>
<span class="sd">        If `True`, return the final filter delay values along with the PCEN output `P`.</span>
<span class="sd">        This is primarily useful in streaming contexts, where the final state of one</span>
<span class="sd">        block of processing should be used to initialize the next block.</span>

<span class="sd">        If `False` (default) only the PCEN values `P` are returned.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : np.ndarray, non-negative [shape=(n, m)]</span>
<span class="sd">        The per-channel energy normalized version of `S`.</span>

<span class="sd">    zf : np.ndarray (optional)</span>
<span class="sd">        The final filter delay values.  Only returned if `return_zf=True`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    amplitude_to_db</span>
<span class="sd">    librosa.onset.onset_strength</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Compare PCEN to log amplitude (dB) scaling on Mel spectra</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(),</span>
<span class="sd">    ...                      offset=10, duration=10)</span>

<span class="sd">    &gt;&gt;&gt; # We recommend scaling y to the range [-2**31, 2**31[ before applying</span>
<span class="sd">    &gt;&gt;&gt; # PCEN&#39;s default parameters. Furthermore, we use power=1 to get a</span>
<span class="sd">    &gt;&gt;&gt; # magnitude spectrum instead of a power spectrum.</span>
<span class="sd">    &gt;&gt;&gt; S = librosa.feature.melspectrogram(y, sr=sr, power=1)</span>
<span class="sd">    &gt;&gt;&gt; log_S = librosa.amplitude_to_db(S, ref=np.max)</span>
<span class="sd">    &gt;&gt;&gt; pcen_S = librosa.pcen(S * (2**31))</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(log_S, x_axis=&#39;time&#39;, y_axis=&#39;mel&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;log amplitude (dB)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(pcen_S, x_axis=&#39;time&#39;, y_axis=&#39;mel&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Per-channel energy normalization&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Compare PCEN with and without max-filtering</span>

<span class="sd">    &gt;&gt;&gt; pcen_max = librosa.pcen(S * (2**31), max_size=3)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(pcen_S, x_axis=&#39;time&#39;, y_axis=&#39;mel&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Per-channel energy normalization (no max-filter)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(pcen_max, x_axis=&#39;time&#39;, y_axis=&#39;mel&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Per-channel energy normalization (max_size=3)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">power</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;power=</span><span class="si">{}</span><span class="s1"> must be nonnegative&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">power</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">gain</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;gain=</span><span class="si">{}</span><span class="s1"> must be non-negative&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gain</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">bias</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;bias=</span><span class="si">{}</span><span class="s1"> must be non-negative&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bias</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">eps</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;eps=</span><span class="si">{}</span><span class="s1"> must be strictly positive&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">time_constant</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;time_constant=</span><span class="si">{}</span><span class="s1"> must be strictly positive&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_constant</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">max_size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;max_size=</span><span class="si">{}</span><span class="s1"> must be a positive integer&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_size</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t_frames</span> <span class="o">=</span> <span class="n">time_constant</span> <span class="o">*</span> <span class="n">sr</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">hop_length</span><span class="p">)</span>
        <span class="c1"># By default, this solves the equation for b:</span>
        <span class="c1">#   b**2  + (1 - b) / t_frames  - 2 = 0</span>
        <span class="c1"># which approximates the full-width half-max of the</span>
        <span class="c1"># squared frequency response of the IIR low-pass filter</span>

        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">t_frames</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t_frames</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;b=</span><span class="si">{}</span><span class="s1"> must be between 0 and 1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;pcen was called on complex input so phase &#39;</span>
                      <span class="s1">&#39;information will be discarded. To suppress this warning, &#39;</span>
                      <span class="s1">&#39;call pcen(np.abs(D)) instead.&#39;</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">S</span>
        <span class="k">elif</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Max-filtering cannot be applied to 1-dimensional input&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Max-filtering a </span><span class="si">{:d}</span><span class="s1">-dimensional spectrogram &#39;</span>
                                         <span class="s1">&#39;requires you to specify max_axis&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
                <span class="c1"># if axis = 0, max_axis=1</span>
                <span class="c1"># if axis = +- 1, max_axis = 0</span>
                <span class="n">max_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">ref</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">maximum_filter1d</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">max_axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Make sure zi matches dimension to input</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ref</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">zi</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter_zi</span><span class="p">([</span><span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])[:]</span>

    <span class="c1"># Temporal integration</span>
    <span class="n">S_smooth</span><span class="p">,</span> <span class="n">zf</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">([</span><span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ref</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span><span class="p">,</span>
                                        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Adaptive gain control</span>
    <span class="c1"># Working in log-space gives us some stability, and a slight speedup</span>
    <span class="n">smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">gain</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">S_smooth</span> <span class="o">/</span> <span class="n">eps</span><span class="p">)))</span>

    <span class="c1"># Dynamic range compression</span>
    <span class="k">if</span> <span class="n">power</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">S_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">smooth</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">bias</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">S_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">power</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">smooth</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">S_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">bias</span><span class="o">**</span><span class="n">power</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">(</span><span class="n">power</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">smooth</span><span class="o">/</span><span class="n">bias</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">return_zf</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S_out</span><span class="p">,</span> <span class="n">zf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S_out</span></div>


<div class="viewcode-block" id="griffinlim"><a class="viewcode-back" href="../../../generated/librosa.core.griffinlim.html#librosa.core.griffinlim">[docs]</a><span class="k">def</span> <span class="nf">griffinlim</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span>
               <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span>
               <span class="n">momentum</span><span class="o">=</span><span class="mf">0.99</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;Approximate magnitude spectrogram inversion using the &quot;fast&quot; Griffin-Lim algorithm [1]_ [2]_.</span>

<span class="sd">    Given a short-time Fourier transform magnitude matrix (`S`), the algorithm randomly</span>
<span class="sd">    initializes phase estimates, and then alternates forward- and inverse-STFT</span>
<span class="sd">    operations.</span>
<span class="sd">    Note that this assumes reconstruction of a real-valued time-domain signal, and</span>
<span class="sd">    that `S` contains only the non-negative frequencies (as computed by</span>
<span class="sd">    `core.stft`).</span>

<span class="sd">    .. [1] Perraudin, N., Balazs, P., &amp; Søndergaard, P. L.</span>
<span class="sd">        &quot;A fast Griffin-Lim algorithm,&quot;</span>
<span class="sd">        IEEE Workshop on Applications of Signal Processing to Audio and Acoustics (pp. 1-4),</span>
<span class="sd">        Oct. 2013.</span>

<span class="sd">    .. [2] D. W. Griffin and J. S. Lim,</span>
<span class="sd">        &quot;Signal estimation from modified short-time Fourier transform,&quot;</span>
<span class="sd">        IEEE Trans. ASSP, vol.32, no.2, pp.236–243, Apr. 1984.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray [shape=(n_fft / 2 + 1, t), non-negative]</span>
<span class="sd">        An array of short-time Fourier transform magnitudes as produced by</span>
<span class="sd">        `core.stft`.</span>

<span class="sd">    n_iter : int &gt; 0</span>
<span class="sd">        The number of iterations to run</span>

<span class="sd">    hop_length : None or int &gt; 0</span>
<span class="sd">        The hop length of the STFT.  If not provided, it will default to `n_fft // 4`</span>

<span class="sd">    win_length : None or int &gt; 0</span>
<span class="sd">        The window length of the STFT.  By default, it will equal `n_fft`</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        A window specification as supported by `stft` or `istft`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        If `True`, the STFT is assumed to use centered frames.</span>
<span class="sd">        If `False`, the STFT is assumed to use left-aligned frames.</span>

<span class="sd">    dtype : np.dtype</span>
<span class="sd">        Real numeric type for the time-domain signal.  Default is 32-bit float.</span>

<span class="sd">    length : None or int &gt; 0</span>
<span class="sd">        If provided, the output `y` is zero-padded or clipped to exactly `length`</span>
<span class="sd">        samples.</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>

<span class="sd">    momentum : number &gt;= 0</span>
<span class="sd">        The momentum parameter for fast Griffin-Lim.</span>
<span class="sd">        Setting this to 0 recovers the original Griffin-Lim method [1]_.</span>
<span class="sd">        Values near 1 can lead to faster convergence, but above 1 may not converge.</span>

<span class="sd">    init : None or &#39;random&#39; [default]</span>
<span class="sd">        If &#39;random&#39; (the default), then phase values are initialized randomly</span>
<span class="sd">        according to `random_state`.  This is recommended when the input `S` is</span>
<span class="sd">        a magnitude spectrogram with no initial phase estimates.</span>

<span class="sd">        If `None`, then the phase is initialized from `S`.  This is useful when</span>
<span class="sd">        an initial guess for phase can be provided, or when you want to resume</span>
<span class="sd">        Griffin-Lim from a previous output.</span>

<span class="sd">    random_state : None, int, or np.random.RandomState</span>
<span class="sd">        If int, random_state is the seed used by the random number generator</span>
<span class="sd">        for phase initialization.</span>

<span class="sd">        If `np.random.RandomState` instance, the random number</span>
<span class="sd">        generator itself.</span>

<span class="sd">        If `None`, defaults to the current `np.random` object.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        time-domain signal reconstructed from `S`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    stft</span>
<span class="sd">    istft</span>
<span class="sd">    magphase</span>
<span class="sd">    filters.get_window</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A basic STFT inverse example</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(), duration=5, offset=30)</span>
<span class="sd">    &gt;&gt;&gt; # Get the magnitude spectrogram</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; # Invert using Griffin-Lim</span>
<span class="sd">    &gt;&gt;&gt; y_inv = librosa.griffinlim(S)</span>
<span class="sd">    &gt;&gt;&gt; # Invert without estimating phase</span>
<span class="sd">    &gt;&gt;&gt; y_istft = librosa.istft(S)</span>

<span class="sd">    Wave-plot the results</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; ax = plt.subplot(3,1,1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.waveplot(y, sr=sr, color=&#39;b&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3,1,2, sharex=ax, sharey=ax)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.waveplot(y_inv, sr=sr, color=&#39;g&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Griffin-Lim reconstruction&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3,1,3, sharex=ax, sharey=ax)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.waveplot(y_istft, sr=sr, color=&#39;r&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Magnitude-only istft reconstruction&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">random_state</span>

    <span class="k">if</span> <span class="n">momentum</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Griffin-Lim with momentum=</span><span class="si">{}</span><span class="s1"> &gt; 1 can be unstable. &#39;</span>
                      <span class="s1">&#39;Proceed with caution!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">momentum</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">momentum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;griffinlim() called with momentum=</span><span class="si">{}</span><span class="s1"> &lt; 0&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">momentum</span><span class="p">))</span>

    <span class="c1"># Infer n_fft from the spectrogram shape</span>
    <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># using complex64 will keep the result to minimal necessary precision</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">init</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
        <span class="c1"># randomly initialize the phase</span>
        <span class="n">angles</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Initialize an all ones complex matrix</span>
        <span class="n">angles</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;init=</span><span class="si">{}</span><span class="s2"> must either None or &#39;random&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">init</span><span class="p">))</span>

    <span class="c1"># And initialize the previous iterate to 0</span>
    <span class="n">rebuilt</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
        <span class="c1"># Store the previous iterate</span>
        <span class="n">tprev</span> <span class="o">=</span> <span class="n">rebuilt</span>

        <span class="c1"># Invert with our current estimate of the phases</span>
        <span class="n">inverse</span> <span class="o">=</span> <span class="n">istft</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">angles</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
                        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>

        <span class="c1"># Rebuild the spectrogram</span>
        <span class="n">rebuilt</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span><span class="n">inverse</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                       <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                       <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

        <span class="c1"># Update our phase estimates</span>
        <span class="n">angles</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">rebuilt</span> <span class="o">-</span> <span class="p">(</span><span class="n">momentum</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">momentum</span><span class="p">))</span> <span class="o">*</span> <span class="n">tprev</span>
        <span class="n">angles</span><span class="p">[:]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-16</span>

    <span class="c1"># Return the final phase estimates</span>
    <span class="k">return</span> <span class="n">istft</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">angles</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span> <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span>
                 <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">win_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Helper function to retrieve a magnitude spectrogram.</span>

<span class="sd">    This is primarily used in feature extraction functions that can operate on</span>
<span class="sd">    either audio time-series or spectrogram input.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : None or np.ndarray [ndim=1]</span>
<span class="sd">        If provided, an audio time series</span>

<span class="sd">    S : None or np.ndarray</span>
<span class="sd">        Spectrogram input, optional</span>

<span class="sd">    n_fft : int &gt; 0</span>
<span class="sd">        STFT window size</span>

<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        STFT hop length</span>

<span class="sd">    power : float &gt; 0</span>
<span class="sd">        Exponent for the magnitude spectrogram,</span>
<span class="sd">        e.g., 1 for energy, 2 for power, etc.</span>

<span class="sd">    win_length : int &lt;= n_fft [scalar]</span>
<span class="sd">        Each frame of audio is windowed by `window()`.</span>
<span class="sd">        The window will be of length `win_length` and then padded</span>
<span class="sd">        with zeros to match `n_fft`.</span>

<span class="sd">        If unspecified, defaults to ``win_length = n_fft``.</span>

<span class="sd">    window : string, tuple, number, function, or np.ndarray [shape=(n_fft,)]</span>
<span class="sd">        - a window specification (string, tuple, or number);</span>
<span class="sd">          see `scipy.signal.get_window`</span>
<span class="sd">        - a window function, such as `scipy.signal.hanning`</span>
<span class="sd">        - a vector or array of length `n_fft`</span>

<span class="sd">        .. see also:: `filters.get_window`</span>

<span class="sd">    center : boolean</span>
<span class="sd">        - If `True`, the signal `y` is padded so that frame</span>
<span class="sd">          `t` is centered at `y[t * hop_length]`.</span>
<span class="sd">        - If `False`, then frame `t` begins at `y[t * hop_length]`</span>

<span class="sd">    pad_mode : string</span>
<span class="sd">        If `center=True`, the padding mode to use at the edges of the signal.</span>
<span class="sd">        By default, STFT uses reflection padding.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_out : np.ndarray [dtype=np.float32]</span>
<span class="sd">        - If `S` is provided as input, then `S_out == S`</span>
<span class="sd">        - Else, `S_out = |stft(y, ...)|**power`</span>

<span class="sd">    n_fft : int &gt; 0</span>
<span class="sd">        - If `S` is provided, then `n_fft` is inferred from `S`</span>
<span class="sd">        - Else, copied from input</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Infer n_fft from spectrogram shape</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Otherwise, compute a magnitude spectrogram from input</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                        <span class="n">win_length</span><span class="o">=</span><span class="n">win_length</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">))</span><span class="o">**</span><span class="n">power</span>

    <span class="k">return</span> <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013--2019, librosa development team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
        <span class="fa fa-book"> Other Versions</span>
        v: 0.7.2
        <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Tags</dt>
            <dd><a href="../../../0.4.1/index.html">0.4.1</a></dd>
            <dd><a href="../../../0.4.2/index.html">0.4.2</a></dd>
            <dd><a href="../../../0.4.3/index.html">0.4.3</a></dd>
            <dd><a href="../../../0.5.0/index.html">0.5.0</a></dd>
            <dd><a href="../../../0.5.1/index.html">0.5.1</a></dd>
            <dd><a href="../../../0.6.0/index.html">0.6.0</a></dd>
            <dd><a href="../../../0.6.1/index.html">0.6.1</a></dd>
            <dd><a href="../../../0.6.2/index.html">0.6.2</a></dd>
            <dd><a href="../../../0.6.3/index.html">0.6.3</a></dd>
            <dd><a href="../../../0.7.0/index.html">0.7.0</a></dd>
            <dd><a href="../../../0.7.1/index.html">0.7.1</a></dd>
            <dd><a href="../../../0.7.2/_modules/librosa/core/spectrum.html">0.7.2</a></dd>
            <dd><a href="../../../v0.1.0/index.html">v0.1.0</a></dd>
            <dd><a href="../../../v0.4.0/index.html">v0.4.0</a></dd>
        </dl>
        <dl>
            <dt>Branches</dt>
            <dd><a href="../../../master/index.html">master</a></dd>
        </dl>
    </div>
</div>


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>