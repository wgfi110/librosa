

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>librosa.sequence &mdash; librosa 0.7.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'0.7.2',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/banner.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> librosa
          

          
          </a>

          
            
            
              <div class="version">
                0.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sequence.html">Sequential modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../util.html">Utilities</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cache.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ioformats.html">Advanced I/O Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced.html">Advanced examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">librosa</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>librosa.sequence</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  


    
    



    <p class="scv-banner scv-sphinx_rtd_theme"><b>Warning:</b> This document is for the development version of librosa.</p>
<h1>Source code for librosa.sequence</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- encoding: utf-8 -*-</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Sequential modeling</span>
<span class="sd">===================</span>

<span class="sd">Sequence alignment</span>
<span class="sd">------------------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    dtw</span>
<span class="sd">    rqa</span>

<span class="sd">Viterbi decoding</span>
<span class="sd">----------------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    viterbi</span>
<span class="sd">    viterbi_discriminative</span>
<span class="sd">    viterbi_binary</span>

<span class="sd">Transition matrices</span>
<span class="sd">-------------------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    transition_uniform</span>
<span class="sd">    transition_loop</span>
<span class="sd">    transition_cycle</span>
<span class="sd">    transition_local</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">cdist</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="k">import</span> <span class="n">jit</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">pad_center</span><span class="p">,</span> <span class="n">fill_off_diagonal</span>
<span class="kn">from</span> <span class="nn">.util.exceptions</span> <span class="k">import</span> <span class="n">ParameterError</span>
<span class="kn">from</span> <span class="nn">.filters</span> <span class="k">import</span> <span class="n">get_window</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dtw&#39;</span><span class="p">,</span>
           <span class="s1">&#39;rqa&#39;</span><span class="p">,</span>
           <span class="s1">&#39;viterbi&#39;</span><span class="p">,</span>
           <span class="s1">&#39;viterbi_discriminative&#39;</span><span class="p">,</span>
           <span class="s1">&#39;viterbi_binary&#39;</span><span class="p">,</span>
           <span class="s1">&#39;transition_uniform&#39;</span><span class="p">,</span>
           <span class="s1">&#39;transition_loop&#39;</span><span class="p">,</span>
           <span class="s1">&#39;transition_cycle&#39;</span><span class="p">,</span>
           <span class="s1">&#39;transition_local&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="dtw"><a class="viewcode-back" href="../../generated/librosa.sequence.dtw.html#librosa.sequence.dtw">[docs]</a><span class="k">def</span> <span class="nf">dtw</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">weights_add</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights_mul</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subseq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">backtrack</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">global_constraints</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">band_rad</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Dynamic time warping (DTW).</span>

<span class="sd">    This function performs a DTW and path backtracking on two sequences.</span>
<span class="sd">    We follow the nomenclature and algorithmic approach as described in [1]_.</span>

<span class="sd">    .. [1] Meinard Mueller</span>
<span class="sd">           Fundamentals of Music Processing â€” Audio, Analysis, Algorithms, Applications</span>
<span class="sd">           Springer Verlag, ISBN: 978-3-319-21944-8, 2015.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : np.ndarray [shape=(K, N)]</span>
<span class="sd">        audio feature matrix (e.g., chroma features)</span>

<span class="sd">    Y : np.ndarray [shape=(K, M)]</span>
<span class="sd">        audio feature matrix (e.g., chroma features)</span>

<span class="sd">    C : np.ndarray [shape=(N, M)]</span>
<span class="sd">        Precomputed distance matrix. If supplied, X and Y must not be supplied and</span>
<span class="sd">        ``metric`` will be ignored.</span>

<span class="sd">    metric : str</span>
<span class="sd">        Identifier for the cost-function as documented</span>
<span class="sd">        in `scipy.spatial.distance.cdist()`</span>

<span class="sd">    step_sizes_sigma : np.ndarray [shape=[n, 2]]</span>
<span class="sd">        Specifies allowed step sizes as used by the dtw.</span>

<span class="sd">    weights_add : np.ndarray [shape=[n, ]]</span>
<span class="sd">        Additive weights to penalize certain step sizes.</span>

<span class="sd">    weights_mul : np.ndarray [shape=[n, ]]</span>
<span class="sd">        Multiplicative weights to penalize certain step sizes.</span>

<span class="sd">    subseq : binary</span>
<span class="sd">        Enable subsequence DTW, e.g., for retrieval tasks.</span>

<span class="sd">    backtrack : binary</span>
<span class="sd">        Enable backtracking in accumulated cost matrix.</span>

<span class="sd">    global_constraints : binary</span>
<span class="sd">        Applies global constraints to the cost matrix ``C`` (Sakoe-Chiba band).</span>

<span class="sd">    band_rad : float</span>
<span class="sd">        The Sakoe-Chiba band radius (1/2 of the width) will be</span>
<span class="sd">        ``int(radius*min(C.shape))``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D : np.ndarray [shape=(N,M)]</span>
<span class="sd">        accumulated cost matrix.</span>
<span class="sd">        D[N,M] is the total alignment cost.</span>
<span class="sd">        When doing subsequence DTW, D[N,:] indicates a matching function.</span>

<span class="sd">    wp : np.ndarray [shape=(N,2)]</span>
<span class="sd">        Warping path with index pairs.</span>
<span class="sd">        Each row of the array contains an index pair n,m).</span>
<span class="sd">        Only returned when ``backtrack`` is True.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If you are doing diagonal matching and Y is shorter than X or if an</span>
<span class="sd">        incompatible combination of X, Y, and C are supplied.</span>

<span class="sd">        If your input dimensions are incompatible.</span>

<span class="sd">        If the cost matrix has NaN values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(), offset=10, duration=15)</span>
<span class="sd">    &gt;&gt;&gt; X = librosa.feature.chroma_cens(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; noise = np.random.rand(X.shape[0], 200)</span>
<span class="sd">    &gt;&gt;&gt; Y = np.concatenate((noise, noise, X, noise), axis=1)</span>
<span class="sd">    &gt;&gt;&gt; D, wp = librosa.sequence.dtw(X, Y, subseq=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(D, x_axis=&#39;frames&#39;, y_axis=&#39;frames&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Database excerpt&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(wp[:, 1], wp[:, 0], label=&#39;Optimal path&#39;, color=&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(D[-1, :] / wp.shape[0])</span>
<span class="sd">    &gt;&gt;&gt; plt.xlim([0, Y.shape[1]])</span>
<span class="sd">    &gt;&gt;&gt; plt.ylim([0, 2])</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Matching cost function&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Default Parameters</span>
    <span class="n">default_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="n">default_weights_add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">default_weights_mul</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">step_sizes_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Use the default steps</span>
        <span class="n">step_sizes_sigma</span> <span class="o">=</span> <span class="n">default_steps</span>

        <span class="c1"># Use default weights if none are provided</span>
        <span class="k">if</span> <span class="n">weights_add</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights_add</span> <span class="o">=</span> <span class="n">default_weights_add</span>

        <span class="k">if</span> <span class="n">weights_mul</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights_mul</span> <span class="o">=</span> <span class="n">default_weights_mul</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If we have custom steps but no weights, construct them here</span>
        <span class="k">if</span> <span class="n">weights_add</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights_add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">step_sizes_sigma</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights_mul</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights_mul</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">step_sizes_sigma</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="c1"># Make the default step weights infinite so that they are never</span>
        <span class="c1"># preferred over custom steps</span>
        <span class="n">default_weights_add</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="n">default_weights_mul</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

        <span class="c1"># Append custom steps and weights to our defaults</span>
        <span class="n">step_sizes_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">default_steps</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="p">))</span>
        <span class="n">weights_add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">default_weights_add</span><span class="p">,</span> <span class="n">weights_add</span><span class="p">))</span>
        <span class="n">weights_mul</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">default_weights_mul</span><span class="p">,</span> <span class="n">weights_mul</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">step_sizes_sigma</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;step_sizes_sigma cannot contain negative values&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">step_sizes_sigma</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights_add</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;len(weights_add) must be equal to len(step_sizes_sigma)&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">step_sizes_sigma</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights_mul</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;len(weights_mul) must be equal to len(step_sizes_sigma)&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">X</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;If C is not supplied, both X and Y must be supplied&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">Y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;If C is supplied, both X and Y must not be supplied&#39;</span><span class="p">)</span>

    <span class="n">c_is_transposed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># calculate pair-wise distances, unless already supplied.</span>
    <span class="c1"># C_local will keep track of whether the distance matrix was supplied</span>
    <span class="c1"># by the user (False) or constructed locally (True)</span>
    <span class="n">C_local</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">C_local</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># take care of dimensions</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;scipy.spatial.distance.cdist returned an error.</span><span class="se">\n</span><span class="s1">&#39;</span>
                   <span class="s1">&#39;Please provide your input in the form X.shape=(K, N) and Y.shape=(K, M).</span><span class="se">\n</span><span class="s1">&#39;</span>
                   <span class="s1">&#39;1-dimensional sequences should be reshaped to X.shape=(1, N) and Y.shape=(1, M).&#39;</span><span class="p">)</span>
            <span class="n">six</span><span class="o">.</span><span class="n">reraise</span><span class="p">(</span><span class="n">ParameterError</span><span class="p">,</span> <span class="n">ParameterError</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

        <span class="c1"># for subsequence matching:</span>
        <span class="c1"># if N &gt; M, Y can be a subsequence of X</span>
        <span class="k">if</span> <span class="n">subseq</span> <span class="ow">and</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span>
            <span class="n">c_is_transposed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

    <span class="c1"># if diagonal matching, Y has to be longer than X</span>
    <span class="c1"># (X simply cannot be contained in Y)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">step_sizes_sigma</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;For diagonal matching: Y.shape[1] &gt;= X.shape[1] &#39;</span>
                             <span class="s1">&#39;(C.shape[1] &gt;= C.shape[0])&#39;</span><span class="p">)</span>

    <span class="n">max_0</span> <span class="o">=</span> <span class="n">step_sizes_sigma</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">max_1</span> <span class="o">=</span> <span class="n">step_sizes_sigma</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1"># check C here for nans before building global constraints</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">C</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;DTW cost matrix C has NaN values. &#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">global_constraints</span><span class="p">:</span>
        <span class="c1"># Apply global constraints to the cost matrix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">C_local</span><span class="p">:</span>
            <span class="c1"># If C was provided as input, make a copy here</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">fill_off_diagonal</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">band_rad</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

    <span class="c1"># initialize whole matrix with infinity values</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">max_0</span><span class="p">,</span> <span class="n">max_1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="c1"># set starting point to C[0, 0]</span>
    <span class="n">D</span><span class="p">[</span><span class="n">max_0</span><span class="p">,</span> <span class="n">max_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">subseq</span><span class="p">:</span>
        <span class="n">D</span><span class="p">[</span><span class="n">max_0</span><span class="p">,</span> <span class="n">max_1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># initialize step matrix with -1</span>
    <span class="c1"># will be filled in calc_accu_cost() with indices from step_sizes_sigma</span>
    <span class="n">D_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="c1"># these steps correspond to left- (first row) and up-(first column) moves</span>
    <span class="n">D_steps</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">D_steps</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1"># calculate accumulated cost matrix</span>
    <span class="n">D</span><span class="p">,</span> <span class="n">D_steps</span> <span class="o">=</span> <span class="n">__dtw_calc_accu_cost</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">D_steps</span><span class="p">,</span>
                                      <span class="n">step_sizes_sigma</span><span class="p">,</span>
                                      <span class="n">weights_mul</span><span class="p">,</span> <span class="n">weights_add</span><span class="p">,</span>
                                      <span class="n">max_0</span><span class="p">,</span> <span class="n">max_1</span><span class="p">)</span>

    <span class="c1"># delete infinity rows and columns</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">max_0</span><span class="p">:,</span> <span class="n">max_1</span><span class="p">:]</span>
    <span class="n">D_steps</span> <span class="o">=</span> <span class="n">D_steps</span><span class="p">[</span><span class="n">max_0</span><span class="p">:,</span> <span class="n">max_1</span><span class="p">:]</span>

    <span class="k">if</span> <span class="n">backtrack</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">subseq</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;No valid sub-sequence warping path could &#39;</span>
                                     <span class="s1">&#39;be constructed with the given step sizes.&#39;</span><span class="p">)</span>
            <span class="c1"># search for global minimum in last row of D-matrix</span>
            <span class="n">wp_end_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">wp</span> <span class="o">=</span> <span class="n">__dtw_backtracking</span><span class="p">(</span><span class="n">D_steps</span><span class="p">[:,</span> <span class="p">:</span><span class="n">wp_end_idx</span><span class="p">],</span> <span class="n">step_sizes_sigma</span><span class="p">,</span> <span class="n">subseq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># perform warping path backtracking</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;No valid sub-sequence warping path could &#39;</span>
                                     <span class="s1">&#39;be constructed with the given step sizes.&#39;</span><span class="p">)</span>

            <span class="n">wp</span> <span class="o">=</span> <span class="n">__dtw_backtracking</span><span class="p">(</span><span class="n">D_steps</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="p">,</span> <span class="n">subseq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Unable to compute a full DTW warping path. &#39;</span>
                                     <span class="s1">&#39;You may want to try again with subseq=True.&#39;</span><span class="p">)</span>

        <span class="n">wp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># since we transposed in the beginning, we have to adjust the index pairs back</span>
        <span class="k">if</span> <span class="n">subseq</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span>
                <span class="n">c_is_transposed</span> <span class="ow">or</span>
                <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">wp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">wp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">D</span></div>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">__dtw_calc_accu_cost</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">D_steps</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="p">,</span>
                         <span class="n">weights_mul</span><span class="p">,</span> <span class="n">weights_add</span><span class="p">,</span> <span class="n">max_0</span><span class="p">,</span> <span class="n">max_1</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&#39;&#39;&#39;Calculate the accumulated cost matrix D.</span>

<span class="sd">    Use dynamic programming to calculate the accumulated costs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C : np.ndarray [shape=(N, M)]</span>
<span class="sd">        pre-computed cost matrix</span>

<span class="sd">    D : np.ndarray [shape=(N, M)]</span>
<span class="sd">        accumulated cost matrix</span>

<span class="sd">    D_steps : np.ndarray [shape=(N, M)]</span>
<span class="sd">        steps which were used for calculating D</span>

<span class="sd">    step_sizes_sigma : np.ndarray [shape=[n, 2]]</span>
<span class="sd">        Specifies allowed step sizes as used by the dtw.</span>

<span class="sd">    weights_add : np.ndarray [shape=[n, ]]</span>
<span class="sd">        Additive weights to penalize certain step sizes.</span>

<span class="sd">    weights_mul : np.ndarray [shape=[n, ]]</span>
<span class="sd">        Multiplicative weights to penalize certain step sizes.</span>

<span class="sd">    max_0 : int</span>
<span class="sd">        maximum number of steps in step_sizes_sigma in dim 0.</span>

<span class="sd">    max_1 : int</span>
<span class="sd">        maximum number of steps in step_sizes_sigma in dim 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D : np.ndarray [shape=(N,M)]</span>
<span class="sd">        accumulated cost matrix.</span>
<span class="sd">        D[N,M] is the total alignment cost.</span>
<span class="sd">        When doing subsequence DTW, D[N,:] indicates a matching function.</span>

<span class="sd">    D_steps : np.ndarray [shape=(N,M)]</span>
<span class="sd">        steps which were used for calculating D.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dtw</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">cur_n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_0</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">cur_m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_1</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># accumulate costs</span>
            <span class="k">for</span> <span class="n">cur_step_idx</span><span class="p">,</span> <span class="n">cur_w_add</span><span class="p">,</span> <span class="n">cur_w_mul</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">step_sizes_sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                                          <span class="n">weights_add</span><span class="p">,</span> <span class="n">weights_mul</span><span class="p">):</span>
                <span class="n">cur_D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">cur_n</span> <span class="o">-</span> <span class="n">step_sizes_sigma</span><span class="p">[</span><span class="n">cur_step_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="n">cur_m</span> <span class="o">-</span> <span class="n">step_sizes_sigma</span><span class="p">[</span><span class="n">cur_step_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="n">cur_C</span> <span class="o">=</span> <span class="n">cur_w_mul</span> <span class="o">*</span> <span class="n">C</span><span class="p">[</span><span class="n">cur_n</span> <span class="o">-</span> <span class="n">max_0</span><span class="p">,</span> <span class="n">cur_m</span> <span class="o">-</span> <span class="n">max_1</span><span class="p">]</span>
                <span class="n">cur_C</span> <span class="o">+=</span> <span class="n">cur_w_add</span>
                <span class="n">cur_cost</span> <span class="o">=</span> <span class="n">cur_D</span> <span class="o">+</span> <span class="n">cur_C</span>

                <span class="c1"># check if cur_cost is smaller than the one stored in D</span>
                <span class="k">if</span> <span class="n">cur_cost</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">cur_n</span><span class="p">,</span> <span class="n">cur_m</span><span class="p">]:</span>
                    <span class="n">D</span><span class="p">[</span><span class="n">cur_n</span><span class="p">,</span> <span class="n">cur_m</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_cost</span>

                    <span class="c1"># save step-index</span>
                    <span class="n">D_steps</span><span class="p">[</span><span class="n">cur_n</span><span class="p">,</span> <span class="n">cur_m</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_step_idx</span>

    <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">D_steps</span>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">__dtw_backtracking</span><span class="p">(</span><span class="n">D_steps</span><span class="p">,</span> <span class="n">step_sizes_sigma</span><span class="p">,</span> <span class="n">subseq</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&#39;&#39;&#39;Backtrack optimal warping path.</span>

<span class="sd">    Uses the saved step sizes from the cost accumulation</span>
<span class="sd">    step to backtrack the index pairs for an optimal</span>
<span class="sd">    warping path.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D_steps : np.ndarray [shape=(N, M)]</span>
<span class="sd">        Saved indices of the used steps used in the calculation of D.</span>

<span class="sd">    step_sizes_sigma : np.ndarray [shape=[n, 2]]</span>
<span class="sd">        Specifies allowed step sizes as used by the dtw.</span>

<span class="sd">    subseq : binary</span>
<span class="sd">        Enable subsequence DTW, e.g., for retrieval tasks.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wp : list [shape=(N,)]</span>
<span class="sd">        Warping path with index pairs.</span>
<span class="sd">        Each list entry contains an index pair</span>
<span class="sd">        (n,m) as a tuple</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dtw</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">wp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Set starting point D(N,M) and append it to the path</span>
    <span class="n">cur_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">D_steps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">D_steps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">wp</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cur_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Loop backwards.</span>
    <span class="c1"># Stop criteria:</span>
    <span class="c1"># Setting it to (0, 0) does not work for the subsequence dtw,</span>
    <span class="c1"># so we only ask to reach the first row of the matrix.</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">subseq</span> <span class="ow">and</span> <span class="n">cur_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">subseq</span> <span class="ow">and</span> <span class="n">cur_idx</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="n">cur_step_idx</span> <span class="o">=</span> <span class="n">D_steps</span><span class="p">[(</span><span class="n">cur_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="c1"># save tuple with minimal acc. cost in path</span>
        <span class="n">cur_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">cur_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">step_sizes_sigma</span><span class="p">[</span><span class="n">cur_step_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                   <span class="n">cur_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">step_sizes_sigma</span><span class="p">[</span><span class="n">cur_step_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># If we run off the side of the cost matrix, break here</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">cur_idx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># append to warping path</span>
        <span class="n">wp</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cur_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cur_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">wp</span>


<div class="viewcode-block" id="rqa"><a class="viewcode-back" href="../../generated/librosa.sequence.rqa.html#librosa.sequence.rqa">[docs]</a><span class="k">def</span> <span class="nf">rqa</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">gap_onset</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">gap_extend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">knight_moves</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">backtrack</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Recurrence quantification analysis (RQA)</span>

<span class="sd">    This function implements different forms of RQA as described by</span>
<span class="sd">    Serra, Serra, and Andrzejak [1]_.  These methods take as input</span>
<span class="sd">    a self- or cross-similarity matrix `sim`, and calculate the value</span>
<span class="sd">    of path alignments by dynamic programming.</span>

<span class="sd">    Note that unlike dynamic time warping (`dtw`), alignment paths here are</span>
<span class="sd">    maximized, not minimized, so the input should measure similarity rather</span>
<span class="sd">    than distance.</span>

<span class="sd">    The simplest RQA method, denoted as `L` [1]_ (equation 3) and equivalent</span>
<span class="sd">    to the method described by Eckman, Kamphorst, and Ruelle [2]_, accumulates</span>
<span class="sd">    the length of diagonal paths with positive values in the input:</span>

<span class="sd">        - `score[i, j] = score[i-1, j-1] + 1`  if `sim[i, j] &gt; 0`</span>
<span class="sd">        - `score[i, j] = 0` otherwise.</span>

<span class="sd">    The second method, denoted as `S` [1]_ (equation 4), is similar to the first,</span>
<span class="sd">    but allows for &quot;knight moves&quot; (as in the chess piece) in addition to strict</span>
<span class="sd">    diagonal moves:</span>

<span class="sd">        - `score[i, j] = max(score[i-1, j-1], score[i-2, j-1], score[i-1, j-2]) + 1`  if `sim[i, j] &gt; 0`</span>
<span class="sd">        - `score[i, j] = 0` otherwise.</span>

<span class="sd">    The third method, denoted as `Q` [1]_ (equations 5 and 6) extends this by</span>
<span class="sd">    allowing gaps in the alignment that incur some cost, rather than a hard</span>
<span class="sd">    reset to 0 whenever `sim[i, j] == 0`.</span>
<span class="sd">    Gaps are penalized by two additional parameters, `gap_onset` and `gap_extend`,</span>
<span class="sd">    which are subtracted from the value of the alignment path every time a gap</span>
<span class="sd">    is introduced or extended (respectively).</span>

<span class="sd">    Note that setting `gap_onset` and `gap_extend` to `np.inf` recovers the second</span>
<span class="sd">    method, and disabling knight moves recovers the first.</span>


<span class="sd">    .. [1] SerrÃ , Joan, Xavier Serra, and Ralph G. Andrzejak.</span>
<span class="sd">        &quot;Cross recurrence quantification for cover song identification.&quot;</span>
<span class="sd">        New Journal of Physics 11, no. 9 (2009): 093017.</span>

<span class="sd">    .. [2] Eckmann, J. P., S. Oliffson Kamphorst, and D. Ruelle.</span>
<span class="sd">        &quot;Recurrence plots of dynamical systems.&quot;</span>
<span class="sd">        World Scientific Series on Nonlinear Science Series A 16 (1995): 441-446.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sim : np.ndarray [shape=(N, M), non-negative]</span>
<span class="sd">        The similarity matrix to use as input.</span>

<span class="sd">        This can either be a recurrence matrix (self-similarity)</span>
<span class="sd">        or a cross-similarity matrix between two sequences.</span>

<span class="sd">    gap_onset : float &gt; 0</span>
<span class="sd">        Penalty for introducing a gap to an alignment sequence</span>

<span class="sd">    gap_extend : float &gt; 0</span>
<span class="sd">        Penalty for extending a gap in an alignment sequence</span>

<span class="sd">    knight_moves : bool</span>
<span class="sd">        If `True` (default), allow for &quot;knight moves&quot; in the alignment,</span>
<span class="sd">        e.g., `(n, m) =&gt; (n + 1, m + 2)` or `(n + 2, m + 1)`.</span>

<span class="sd">        If `False`, only allow for diagonal moves `(n, m) =&gt; (n + 1, m + 1)`.</span>

<span class="sd">    backtrack : bool</span>
<span class="sd">        If `True`, return the alignment path.</span>

<span class="sd">        If `False`, only return the score matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    score : np.ndarray [shape=(N, M)]</span>
<span class="sd">        The alignment score matrix.  `score[n, m]` is the cumulative value of</span>
<span class="sd">        the best alignment sequence ending in frames `n` and `m`.</span>

<span class="sd">    path : np.ndarray [shape=(k, 2)] (optional)</span>
<span class="sd">        If `backtrack=True`, `path` contains a list of pairs of aligned frames</span>
<span class="sd">        in the best alignment sequence.</span>

<span class="sd">        `path[i] = [n, m]` indicates that row `n` aligns to column `m`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    segment.recurrence_matrix</span>
<span class="sd">    segment.cross_similarity</span>
<span class="sd">    dtw</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Simple diagonal path enhancement (L-mode)</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(),</span>
<span class="sd">    ...                      offset=10, duration=30)</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_cqt(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; # Use time-delay embedding to reduce noise</span>
<span class="sd">    &gt;&gt;&gt; chroma_stack = librosa.feature.stack_memory(chroma, n_steps=3)</span>
<span class="sd">    &gt;&gt;&gt; # Build recurrence, suppress self-loops within 1 second</span>
<span class="sd">    &gt;&gt;&gt; rec = librosa.segment.recurrence_matrix(chroma_stack, width=43,</span>
<span class="sd">    ...                                         mode=&#39;affinity&#39;,</span>
<span class="sd">    ...                                         metric=&#39;cosine&#39;)</span>
<span class="sd">    &gt;&gt;&gt; # using infinite cost for gaps enforces strict path continuation</span>
<span class="sd">    &gt;&gt;&gt; L_score, L_path = librosa.sequence.rqa(rec, np.inf, np.inf,</span>
<span class="sd">    ...                                        knight_moves=False)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 4))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1,2,1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(rec, x_axis=&#39;frames&#39;, y_axis=&#39;frames&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Recurrence matrix&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1,2,2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(L_score, x_axis=&#39;frames&#39;, y_axis=&#39;frames&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Alignment score matrix&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(L_path[:, 1], L_path[:, 0], label=&#39;Optimal path&#39;, color=&#39;c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Full alignment using gaps and knight moves</span>

<span class="sd">    &gt;&gt;&gt; # New gaps cost 5, extending old gaps cost 10 for each step</span>
<span class="sd">    &gt;&gt;&gt; score, path = librosa.sequence.rqa(rec, 5, 10)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 4))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1,2,1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(rec, x_axis=&#39;frames&#39;, y_axis=&#39;frames&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Recurrence matrix&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1,2,2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(score, x_axis=&#39;frames&#39;, y_axis=&#39;frames&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Alignment score matrix&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(path[:, 1], path[:, 0], label=&#39;Optimal path&#39;, color=&#39;c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">gap_onset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;gap_onset=</span><span class="si">{}</span><span class="s1"> must be strictly positive&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">gap_extend</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;gap_extend=</span><span class="si">{}</span><span class="s1"> must be strictly positive&#39;</span><span class="p">)</span>

    <span class="n">score</span><span class="p">,</span> <span class="n">pointers</span> <span class="o">=</span> <span class="n">__rqa_dp</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">gap_onset</span><span class="p">,</span> <span class="n">gap_extend</span><span class="p">,</span> <span class="n">knight_moves</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">backtrack</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">__rqa_backtrack</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">pointers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">score</span><span class="p">,</span> <span class="n">path</span>

    <span class="k">return</span> <span class="n">score</span></div>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">__rqa_dp</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">gap_onset</span><span class="p">,</span> <span class="n">gap_extend</span><span class="p">,</span> <span class="n">knight</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&#39;&#39;&#39;RQA dynamic programming implementation&#39;&#39;&#39;</span>

    <span class="c1"># The output array</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sim</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># The backtracking array</span>
    <span class="n">backtrack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

    <span class="c1"># These are place-holder arrays to limit the points being considered</span>
    <span class="c1"># at each step of the DP</span>
    <span class="c1">#</span>
    <span class="c1"># If knight moves are enabled, values are indexed according to</span>
    <span class="c1"># [(-1,-1), (-1, -2), (-2, -1)]</span>
    <span class="c1">#</span>
    <span class="c1"># If knight moves are disabled, then only the first entry is used.</span>
    <span class="c1">#</span>
    <span class="c1"># Using dummy vectors here makes the code a bit cleaner down below.</span>
    <span class="n">sim_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">score_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">knight</span><span class="p">:</span>
        <span class="c1"># Initial limit is for the base case: diagonal + one knight</span>
        <span class="n">init_limit</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># Otherwise, we have 3 positions</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">init_limit</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># backtracking rubric:</span>
    <span class="c1">#   0 ==&gt; diagonal move</span>
    <span class="c1">#   1 ==&gt; knight move up</span>
    <span class="c1">#   2 ==&gt; knight move left</span>
    <span class="c1">#  -1 ==&gt; reset without inclusion</span>
    <span class="c1">#  -2 ==&gt; reset with inclusion (ie positive value at init)</span>

    <span class="c1"># Initialize the first row and column with the data</span>
    <span class="n">score</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">score</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># backtracking initialization: the first row and column are all resets</span>
    <span class="c1"># if there&#39;s a positive link here, it&#39;s an inclusive reset</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Initialize the 1-1 case using only the diagonal</span>
    <span class="k">if</span> <span class="n">sim</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">score</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sim</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">backtrack</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">link</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">score</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">score</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="o">*</span> <span class="n">gap_onset</span> <span class="o">-</span> <span class="p">(</span><span class="o">~</span><span class="n">link</span><span class="p">)</span> <span class="o">*</span> <span class="n">gap_extend</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">score</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Initialize the second row with diagonal and left-knight moves</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">score_values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">sim_values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">t_values</span> <span class="o">=</span> <span class="n">sim_values</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">score_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">])</span>
            <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">score_values</span><span class="p">[</span><span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>  <span class="c1"># or + 1 for binary</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vec</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">score_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">]</span>
                                <span class="o">-</span> <span class="n">t_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">]</span> <span class="o">*</span> <span class="n">gap_onset</span>
                                <span class="o">-</span> <span class="p">(</span><span class="o">~</span><span class="n">t_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">])</span> <span class="o">*</span> <span class="n">gap_extend</span><span class="p">)</span>

            <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">vec</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">])</span>
            <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vec</span><span class="p">[</span><span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]])</span>
            <span class="c1"># Is it a reset?</span>
            <span class="k">if</span> <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Initialize the second column with diagonal and up-knight moves</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">score_values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sim_values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">t_values</span> <span class="o">=</span> <span class="n">sim_values</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">score_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">])</span>
            <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">score_values</span><span class="p">[</span><span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>  <span class="c1"># or + 1 for binary</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">vec</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">score_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">]</span>
                                <span class="o">-</span> <span class="n">t_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">]</span> <span class="o">*</span> <span class="n">gap_onset</span>
                                <span class="o">-</span> <span class="p">(</span><span class="o">~</span><span class="n">t_values</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">])</span> <span class="o">*</span> <span class="n">gap_extend</span><span class="p">)</span>

            <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">vec</span><span class="p">[:</span><span class="n">init_limit</span><span class="p">])</span>
            <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vec</span><span class="p">[</span><span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]])</span>
            <span class="c1"># Is it a reset?</span>
            <span class="k">if</span> <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Now fill in the rest of the table</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">score_values</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">sim_values</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">t_values</span> <span class="o">=</span> <span class="n">sim_values</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if knight is true, it&#39;s max of (-1,-1), (-1, -2), (-2, -1)</span>
                <span class="c1"># otherwise, it&#39;s just the diagonal move (-1, -1)</span>
                <span class="c1"># for backtracking purposes, if the max is 0 then it&#39;s the start of a new sequence</span>
                <span class="c1"># if the max is non-zero, then we extend the existing sequence</span>
                <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">score_values</span><span class="p">[:</span><span class="n">limit</span><span class="p">])</span>
                <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">score_values</span><span class="p">[</span><span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="n">sim</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>  <span class="c1"># or + 1 for binary</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if the max of our options is negative, then it&#39;s a hard reset</span>
                <span class="c1"># otherwise, it&#39;s a skip move</span>
                <span class="n">vec</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">score_values</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span>
                               <span class="o">-</span> <span class="n">t_values</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span> <span class="o">*</span> <span class="n">gap_onset</span>
                               <span class="o">-</span> <span class="p">(</span><span class="o">~</span><span class="n">t_values</span><span class="p">[:</span><span class="n">limit</span><span class="p">])</span> <span class="o">*</span> <span class="n">gap_extend</span><span class="p">)</span>

                <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">vec</span><span class="p">[:</span><span class="n">limit</span><span class="p">])</span>
                <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vec</span><span class="p">[</span><span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]])</span>
                <span class="c1"># Is it a reset?</span>
                <span class="k">if</span> <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">backtrack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">score</span><span class="p">,</span> <span class="n">backtrack</span>


<span class="k">def</span> <span class="nf">__rqa_backtrack</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">pointers</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;RQA path backtracking</span>

<span class="sd">    Given the score matrix and backtracking index array,</span>
<span class="sd">    reconstruct the optimal path.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># backtracking rubric:</span>
    <span class="c1">#   0 ==&gt; diagonal move</span>
    <span class="c1">#   1 ==&gt; knight move up</span>
    <span class="c1">#   2 ==&gt; knight move left</span>
    <span class="c1">#  -1 ==&gt; reset (sim = 0)</span>
    <span class="c1">#  -2 ==&gt; start of sequence (sim &gt; 0)</span>

    <span class="c1"># This array maps the backtracking values to the</span>
    <span class="c1"># relative index offsets</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># Find the maximum to end the path</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">score</span><span class="p">),</span> <span class="n">score</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Construct the path</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">bt_index</span> <span class="o">=</span> <span class="n">pointers</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span>

        <span class="c1"># A -1 indicates a non-inclusive reset</span>
        <span class="c1"># this can only happen when sim[idx] == 0,</span>
        <span class="c1"># and a reset with zero score should not be included</span>
        <span class="c1"># in the path.  In this case, we&#39;re done.</span>
        <span class="k">if</span> <span class="n">bt_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># Other bt_index values are okay for inclusion</span>
        <span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="c1"># -2 indicates beginning of sequence,</span>
        <span class="c1"># so we can&#39;t backtrack any further</span>
        <span class="k">if</span> <span class="n">bt_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># Otherwise, prepend this index and continue</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="n">bt_index</span><span class="p">][</span><span class="n">_</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))]</span>

    <span class="c1"># If there&#39;s no alignment path at all, eg an empty cross-similarity</span>
    <span class="c1"># matrix, return a properly shaped and typed array</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_viterbi</span><span class="p">(</span><span class="n">log_prob</span><span class="p">,</span> <span class="n">log_trans</span><span class="p">,</span> <span class="n">log_p_init</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">ptr</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&#39;&#39;&#39;Core Viterbi algorithm.</span>

<span class="sd">    This is intended for internal use only.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_prob : np.ndarray [shape=(T, m)]</span>
<span class="sd">        `log_prob[t, s]` is the conditional log-likelihood</span>
<span class="sd">        log P[X = X(t) | State(t) = s]</span>

<span class="sd">    log_trans : np.ndarray [shape=(m, m)]</span>
<span class="sd">        The log transition matrix</span>
<span class="sd">        `log_trans[i, j]` = log P[State(t+1) = j | State(t) = i]</span>

<span class="sd">    log_p_init : np.ndarray [shape=(m,)]</span>
<span class="sd">        log of the initial state distribution</span>

<span class="sd">    state : np.ndarray [shape=(T,), dtype=int]</span>
<span class="sd">        Pre-allocated state index array</span>

<span class="sd">    value : np.ndarray [shape=(T, m)] float</span>
<span class="sd">        Pre-allocated value array</span>

<span class="sd">    ptr : np.ndarray [shape=(T, m), dtype=int]</span>
<span class="sd">        Pre-allocated pointer array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        All computations are performed in-place on `state, value, ptr`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">n_steps</span><span class="p">,</span> <span class="n">n_states</span> <span class="o">=</span> <span class="n">log_prob</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># factor in initial state distribution</span>
    <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_prob</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">log_p_init</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">):</span>
        <span class="c1"># Want V[t, j] &lt;- p[t, j] * max_k V[t-1, k] * A[k, j]</span>
        <span class="c1">#    assume at time t-1 we were in state k</span>
        <span class="c1">#    transition k -&gt; j</span>

        <span class="c1"># Broadcast over rows:</span>
        <span class="c1">#    Tout[k, j] = V[t-1, k] * A[k, j]</span>
        <span class="c1">#    then take the max over columns</span>
        <span class="c1"># We&#39;ll do this in log-space for stability</span>

        <span class="n">trans_out</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">log_trans</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Unroll the max/argmax loop to enable numba support</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="n">ptr</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">trans_out</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="c1"># value[t, j] = log_prob[t, j] + np.max(trans_out[j])</span>
            <span class="n">value</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_prob</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">trans_out</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span>

    <span class="c1"># Now roll backward</span>

    <span class="c1"># Get the last state</span>
    <span class="n">state</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_steps</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">state</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">state</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
    <span class="c1"># Done.</span>


<div class="viewcode-block" id="viterbi"><a class="viewcode-back" href="../../generated/librosa.sequence.viterbi.html#librosa.sequence.viterbi">[docs]</a><span class="k">def</span> <span class="nf">viterbi</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">transition</span><span class="p">,</span> <span class="n">p_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_logp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Viterbi decoding from observation likelihoods.</span>

<span class="sd">    Given a sequence of observation likelihoods `prob[s, t]`,</span>
<span class="sd">    indicating the conditional likelihood of seeing the observation</span>
<span class="sd">    at time `t` from state `s`, and a transition matrix</span>
<span class="sd">    `transition[i, j]` which encodes the conditional probability of</span>
<span class="sd">    moving from state `i` to state `j`, the Viterbi algorithm [1]_ computes</span>
<span class="sd">    the most likely sequence of states from the observations.</span>

<span class="sd">    .. [1] Viterbi, Andrew. &quot;Error bounds for convolutional codes and an</span>
<span class="sd">        asymptotically optimum decoding algorithm.&quot;</span>
<span class="sd">        IEEE transactions on Information Theory 13.2 (1967): 260-269.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prob : np.ndarray [shape=(n_states, n_steps), non-negative]</span>
<span class="sd">        `prob[s, t]` is the probability of observation at time `t`</span>
<span class="sd">        being generated by state `s`.</span>

<span class="sd">    transition : np.ndarray [shape=(n_states, n_states), non-negative]</span>
<span class="sd">        `transition[i, j]` is the probability of a transition from i-&gt;j.</span>
<span class="sd">        Each row must sum to 1.</span>

<span class="sd">    p_init : np.ndarray [shape=(n_states,)]</span>
<span class="sd">        Optional: initial state distribution.</span>
<span class="sd">        If not provided, a uniform distribution is assumed.</span>

<span class="sd">    return_logp : bool</span>
<span class="sd">        If `True`, return the log-likelihood of the state sequence.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Either `states` or `(states, logp)`:</span>

<span class="sd">    states : np.ndarray [shape=(n_steps,)]</span>
<span class="sd">        The most likely state sequence.</span>

<span class="sd">    logp : scalar [float]</span>
<span class="sd">        If `return_logp=True`, the log probability of `states` given</span>
<span class="sd">        the observations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    viterbi_discriminative : Viterbi decoding from state likelihoods</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Example from https://en.wikipedia.org/wiki/Viterbi_algorithm#Example</span>

<span class="sd">    In this example, we have two states ``healthy`` and ``fever``, with</span>
<span class="sd">    initial probabilities 60% and 40%.</span>

<span class="sd">    We have three observation possibilities: ``normal``, ``cold``, and</span>
<span class="sd">    ``dizzy``, whose probabilities given each state are:</span>

<span class="sd">    ``healthy =&gt; {normal: 50%, cold: 40%, dizzy: 10%}`` and</span>
<span class="sd">    ``fever =&gt; {normal: 10%, cold: 30%, dizzy: 60%}``</span>

<span class="sd">    Finally, we have transition probabilities:</span>

<span class="sd">    ``healthy =&gt; healthy (70%)`` and</span>
<span class="sd">    ``fever =&gt; fever (60%)``.</span>

<span class="sd">    Over three days, we observe the sequence ``[normal, cold, dizzy]``,</span>
<span class="sd">    and wish to know the maximum likelihood assignment of states for the</span>
<span class="sd">    corresponding days, which we compute with the Viterbi algorithm below.</span>

<span class="sd">    &gt;&gt;&gt; p_init = np.array([0.6, 0.4])</span>
<span class="sd">    &gt;&gt;&gt; p_emit = np.array([[0.5, 0.4, 0.1],</span>
<span class="sd">    ...                    [0.1, 0.3, 0.6]])</span>
<span class="sd">    &gt;&gt;&gt; p_trans = np.array([[0.7, 0.3], [0.4, 0.6]])</span>
<span class="sd">    &gt;&gt;&gt; path, logp = librosa.sequence.viterbi(p_emit, p_trans, p_init,</span>
<span class="sd">    ...                                       return_logp=True)</span>
<span class="sd">    &gt;&gt;&gt; print(logp, path)</span>
<span class="sd">    -4.19173690823075 [0 0 1]</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">n_states</span><span class="p">,</span> <span class="n">n_steps</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;transition.shape=</span><span class="si">{}</span><span class="s1">, must be &#39;</span>
                             <span class="s1">&#39;(n_states, n_states)=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                              <span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">transition</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid transition matrix: must be non-negative &#39;</span>
                             <span class="s1">&#39;and sum to 1 on each row.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid probability values: must be between 0 and 1.&#39;</span><span class="p">)</span>

    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Compute log-likelihoods while avoiding log-underflow</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span>
    <span class="n">log_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">transition</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="n">log_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">p_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
        <span class="n">p_init</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">n_states</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_init</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p_init</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid initial state distribution: &#39;</span>
                             <span class="s1">&#39;p_init=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_init</span><span class="p">))</span>

    <span class="n">log_p_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_init</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="n">_viterbi</span><span class="p">(</span><span class="n">log_prob</span><span class="p">,</span> <span class="n">log_trans</span><span class="p">,</span> <span class="n">log_p_init</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_logp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">states</span></div>


<div class="viewcode-block" id="viterbi_discriminative"><a class="viewcode-back" href="../../generated/librosa.sequence.viterbi_discriminative.html#librosa.sequence.viterbi_discriminative">[docs]</a><span class="k">def</span> <span class="nf">viterbi_discriminative</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">transition</span><span class="p">,</span> <span class="n">p_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_logp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Viterbi decoding from discriminative state predictions.</span>

<span class="sd">    Given a sequence of conditional state predictions `prob[s, t]`,</span>
<span class="sd">    indicating the conditional likelihood of state `s` given the</span>
<span class="sd">    observation at time `t`, and a transition matrix `transition[i, j]`</span>
<span class="sd">    which encodes the conditional probability of moving from state `i`</span>
<span class="sd">    to state `j`, the Viterbi algorithm computes the most likely sequence</span>
<span class="sd">    of states from the observations.</span>

<span class="sd">    This implementation uses the standard Viterbi decoding algorithm</span>
<span class="sd">    for observation likelihood sequences, under the assumption that</span>
<span class="sd">    `P[Obs(t) | State(t) = s]` is proportional to</span>
<span class="sd">    `P[State(t) = s | Obs(t)] / P[State(t) = s]`, where the denominator</span>
<span class="sd">    is the marginal probability of state `s` occurring as given by `p_state`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prob : np.ndarray [shape=(n_states, n_steps), non-negative]</span>
<span class="sd">        `prob[s, t]` is the probability of state `s` conditional on</span>
<span class="sd">        the observation at time `t`.</span>
<span class="sd">        Must be non-negative and sum to 1 along each column.</span>

<span class="sd">    transition : np.ndarray [shape=(n_states, n_states), non-negative]</span>
<span class="sd">        `transition[i, j]` is the probability of a transition from i-&gt;j.</span>
<span class="sd">        Each row must sum to 1.</span>

<span class="sd">    p_state : np.ndarray [shape=(n_states,)]</span>
<span class="sd">        Optional: marginal probability distribution over states,</span>
<span class="sd">        must be non-negative and sum to 1.</span>
<span class="sd">        If not provided, a uniform distribution is assumed.</span>

<span class="sd">    p_init : np.ndarray [shape=(n_states,)]</span>
<span class="sd">        Optional: initial state distribution.</span>
<span class="sd">        If not provided, it is assumed to be uniform.</span>

<span class="sd">    return_logp : bool</span>
<span class="sd">        If `True`, return the log-likelihood of the state sequence.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Either `states` or `(states, logp)`:</span>

<span class="sd">    states : np.ndarray [shape=(n_steps,)]</span>
<span class="sd">        The most likely state sequence.</span>

<span class="sd">    logp : scalar [float]</span>
<span class="sd">        If `return_logp=True`, the log probability of `states` given</span>
<span class="sd">        the observations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    viterbi : Viterbi decoding from observation likelihoods</span>
<span class="sd">    viterbi_binary: Viterbi decoding for multi-label, conditional state likelihoods</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    This example constructs a simple, template-based discriminative chord estimator,</span>
<span class="sd">    using CENS chroma as input features.</span>

<span class="sd">    .. note:: this chord model is not accurate enough to use in practice. It is only</span>
<span class="sd">            intended to demonstrate how to use discriminative Viterbi decoding.</span>

<span class="sd">    &gt;&gt;&gt; # Create templates for major, minor, and no-chord qualities</span>
<span class="sd">    &gt;&gt;&gt; maj_template = np.array([1,0,0, 0,1,0, 0,1,0, 0,0,0])</span>
<span class="sd">    &gt;&gt;&gt; min_template = np.array([1,0,0, 1,0,0, 0,1,0, 0,0,0])</span>
<span class="sd">    &gt;&gt;&gt; N_template   = np.array([1,1,1, 1,1,1, 1,1,1, 1,1,1.]) / 4.</span>
<span class="sd">    &gt;&gt;&gt; # Generate the weighting matrix that maps chroma to labels</span>
<span class="sd">    &gt;&gt;&gt; weights = np.zeros((25, 12), dtype=float)</span>
<span class="sd">    &gt;&gt;&gt; labels = [&#39;C:maj&#39;, &#39;C#:maj&#39;, &#39;D:maj&#39;, &#39;D#:maj&#39;, &#39;E:maj&#39;, &#39;F:maj&#39;,</span>
<span class="sd">    ...           &#39;F#:maj&#39;, &#39;G:maj&#39;, &#39;G#:maj&#39;, &#39;A:maj&#39;, &#39;A#:maj&#39;, &#39;B:maj&#39;,</span>
<span class="sd">    ...           &#39;C:min&#39;, &#39;C#:min&#39;, &#39;D:min&#39;, &#39;D#:min&#39;, &#39;E:min&#39;, &#39;F:min&#39;,</span>
<span class="sd">    ...           &#39;F#:min&#39;, &#39;G:min&#39;, &#39;G#:min&#39;, &#39;A:min&#39;, &#39;A#:min&#39;, &#39;B:min&#39;,</span>
<span class="sd">    ...           &#39;N&#39;]</span>
<span class="sd">    &gt;&gt;&gt; for c in range(12):</span>
<span class="sd">    ...     weights[c, :] = np.roll(maj_template, c) # c:maj</span>
<span class="sd">    ...     weights[c + 12, :] = np.roll(min_template, c)  # c:min</span>
<span class="sd">    &gt;&gt;&gt; weights[-1] = N_template  # the last row is the no-chord class</span>
<span class="sd">    &gt;&gt;&gt; # Make a self-loop transition matrix over 25 states</span>
<span class="sd">    &gt;&gt;&gt; trans = librosa.sequence.transition_loop(25, 0.9)</span>

<span class="sd">    &gt;&gt;&gt; # Load in audio and make features</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; # Suppress percussive elements</span>
<span class="sd">    &gt;&gt;&gt; y = librosa.effects.harmonic(y, margin=4)</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_cens(y=y, sr=sr, bins_per_octave=36)</span>
<span class="sd">    &gt;&gt;&gt; # Map chroma (observations) to class (state) likelihoods</span>
<span class="sd">    &gt;&gt;&gt; probs = np.exp(weights.dot(chroma))  # P[class | chroma] ~= exp(template&#39; chroma)</span>
<span class="sd">    &gt;&gt;&gt; probs /= probs.sum(axis=0, keepdims=True)  # probabilities must sum to 1 in each column</span>
<span class="sd">    &gt;&gt;&gt; # Compute independent frame-wise estimates</span>
<span class="sd">    &gt;&gt;&gt; chords_ind = np.argmax(probs, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; # And viterbi estimates</span>
<span class="sd">    &gt;&gt;&gt; chords_vit = librosa.sequence.viterbi_discriminative(probs, trans)</span>

<span class="sd">    &gt;&gt;&gt; # Plot the features and prediction map</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 6))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma, x_axis=&#39;time&#39;, y_axis=&#39;chroma&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(weights, x_axis=&#39;chroma&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.yticks(np.arange(25) + 0.5, labels)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Chord&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; # And plot the results</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 4))</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(probs, x_axis=&#39;time&#39;, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; times = librosa.times_like(chords_vit)</span>
<span class="sd">    &gt;&gt;&gt; plt.scatter(times, chords_ind + 0.75, color=&#39;lime&#39;, alpha=0.5, marker=&#39;+&#39;,</span>
<span class="sd">    ...             s=15, label=&#39;Independent&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.scatter(times, chords_vit + 0.25, color=&#39;deeppink&#39;, alpha=0.5, marker=&#39;o&#39;,</span>
<span class="sd">    ...             s=15, label=&#39;Viterbi&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.yticks(0.5 + np.unique(chords_vit),</span>
<span class="sd">    ...            [labels[i] for i in np.unique(chords_vit)], va=&#39;center&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">n_states</span><span class="p">,</span> <span class="n">n_steps</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;transition.shape=</span><span class="si">{}</span><span class="s1">, must be &#39;</span>
                             <span class="s1">&#39;(n_states, n_states)=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                              <span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">transition</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid transition matrix: must be non-negative &#39;</span>
                             <span class="s1">&#39;and sum to 1 on each row.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid probability values: each column must &#39;</span>
                             <span class="s1">&#39;sum to 1 and be non-negative&#39;</span><span class="p">)</span>

    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Compute log-likelihoods while avoiding log-underflow</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span>

    <span class="c1"># Compute marginal log probabilities while avoiding underflow</span>
    <span class="k">if</span> <span class="n">p_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
        <span class="n">p_state</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">n_states</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">p_state</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Marginal distribution p_state must have shape (n_states,). &#39;</span>
                             <span class="s1">&#39;Got p_state.shape=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_state</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p_state</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid marginal state distribution: &#39;</span>
                             <span class="s1">&#39;p_state=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_state</span><span class="p">))</span>

    <span class="n">log_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">transition</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="n">log_marginal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_state</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="c1"># By Bayes&#39; rule, P[X | Y] * P[Y] = P[Y | X] * P[X]</span>
    <span class="c1"># P[X] is constant for the sake of maximum likelihood inference</span>
    <span class="c1"># and P[Y] is given by the marginal distribution p_state.</span>
    <span class="c1">#</span>
    <span class="c1"># So we have P[X | y] \propto P[Y | x] / P[Y]</span>
    <span class="c1"># if X = observation and Y = states, this can be done in log space as</span>
    <span class="c1"># log P[X | y] \propto \log P[Y | x] - \log P[Y]</span>
    <span class="n">log_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span> <span class="o">-</span> <span class="n">log_marginal</span>

    <span class="k">if</span> <span class="n">p_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
        <span class="n">p_init</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">n_states</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_init</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p_init</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid initial state distribution: &#39;</span>
                             <span class="s1">&#39;p_init=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_init</span><span class="p">))</span>

    <span class="n">log_p_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_init</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="n">_viterbi</span><span class="p">(</span><span class="n">log_prob</span><span class="p">,</span> <span class="n">log_trans</span><span class="p">,</span> <span class="n">log_p_init</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">ptr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_logp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">states</span></div>


<div class="viewcode-block" id="viterbi_binary"><a class="viewcode-back" href="../../generated/librosa.sequence.viterbi_binary.html#librosa.sequence.viterbi_binary">[docs]</a><span class="k">def</span> <span class="nf">viterbi_binary</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">transition</span><span class="p">,</span> <span class="n">p_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_logp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Viterbi decoding from binary (multi-label), discriminative state predictions.</span>

<span class="sd">    Given a sequence of conditional state predictions `prob[s, t]`,</span>
<span class="sd">    indicating the conditional likelihood of state `s` being active</span>
<span class="sd">    conditional on observation at time `t`, and a 2*2 transition matrix</span>
<span class="sd">    `transition` which encodes the conditional probability of moving from</span>
<span class="sd">    state `s` to state `~s` (not-`s`), the Viterbi algorithm computes the</span>
<span class="sd">    most likely sequence of states from the observations.</span>

<span class="sd">    This function differs from `viterbi_discriminative` in that it does not assume the</span>
<span class="sd">    states to be mutually exclusive.  `viterbi_binary` is implemented by</span>
<span class="sd">    transforming the multi-label decoding problem to a collection</span>
<span class="sd">    of binary Viterbi problems (one for each *state* or label).</span>

<span class="sd">    The output is a binary matrix `states[s, t]` indicating whether each</span>
<span class="sd">    state `s` is active at time `t`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prob : np.ndarray [shape=(n_steps,) or (n_states, n_steps)], non-negative</span>
<span class="sd">        `prob[s, t]` is the probability of state `s` being active</span>
<span class="sd">        conditional on the observation at time `t`.</span>
<span class="sd">        Must be non-negative and less than 1.</span>

<span class="sd">        If `prob` is 1-dimensional, it is expanded to shape `(1, n_steps)`.</span>

<span class="sd">    transition : np.ndarray [shape=(2, 2) or (n_states, 2, 2)], non-negative</span>
<span class="sd">        If 2-dimensional, the same transition matrix is applied to each sub-problem.</span>
<span class="sd">        `transition[0, i]` is the probability of the state going from inactive to `i`,</span>
<span class="sd">        `transition[1, i]` is the probability of the state going from active to `i`.</span>
<span class="sd">        Each row must sum to 1.</span>

<span class="sd">        If 3-dimensional, `transition[s]` is interpreted as the 2x2 transition matrix</span>
<span class="sd">        for state label `s`.</span>

<span class="sd">    p_state : np.ndarray [shape=(n_states,)]</span>
<span class="sd">        Optional: marginal probability for each state (between [0,1]).</span>
<span class="sd">        If not provided, a uniform distribution (0.5 for each state)</span>
<span class="sd">        is assumed.</span>

<span class="sd">    p_init : np.ndarray [shape=(n_states,)]</span>
<span class="sd">        Optional: initial state distribution.</span>
<span class="sd">        If not provided, it is assumed to be uniform.</span>

<span class="sd">    return_logp : bool</span>
<span class="sd">        If `True`, return the log-likelihood of the state sequence.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Either `states` or `(states, logp)`:</span>

<span class="sd">    states : np.ndarray [shape=(n_states, n_steps)]</span>
<span class="sd">        The most likely state sequence.</span>

<span class="sd">    logp : np.ndarray [shape=(n_states,)]</span>
<span class="sd">        If `return_logp=True`, the log probability of each state activation</span>
<span class="sd">        sequence `states`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    viterbi : Viterbi decoding from observation likelihoods</span>
<span class="sd">    viterbi_discriminative : Viterbi decoding for discriminative (mutually exclusive) state predictions</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we have a sequence of binary state likelihoods that we want to de-noise</span>
<span class="sd">    under the assumption that state changes are relatively uncommon.  Positive predictions</span>
<span class="sd">    should only be retained if they persist for multiple steps, and any transient predictions</span>
<span class="sd">    should be considered as errors.  This use case arises frequently in problems such as</span>
<span class="sd">    instrument recognition, where state activations tend to be stable over time, but subject</span>
<span class="sd">    to abrupt changes (e.g., when an instrument joins the mix).</span>

<span class="sd">    We assume that the 0 state has a self-transition probability of 90%, and the 1 state</span>
<span class="sd">    has a self-transition probability of 70%.  We assume the marginal and initial</span>
<span class="sd">    probability of either state is 50%.</span>

<span class="sd">    &gt;&gt;&gt; trans = np.array([[0.9, 0.1], [0.3, 0.7]])</span>
<span class="sd">    &gt;&gt;&gt; prob = np.array([0.1, 0.7, 0.4, 0.3, 0.8, 0.9, 0.8, 0.2, 0.6, 0.3])</span>
<span class="sd">    &gt;&gt;&gt; librosa.sequence.viterbi_binary(prob, trans, p_state=0.5, p_init=0.5)</span>
<span class="sd">    array([[0, 0, 0, 0, 1, 1, 1, 0, 0, 0]])</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>

    <span class="n">n_states</span><span class="p">,</span> <span class="n">n_steps</span> <span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">transition</span><span class="p">,</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">transition</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;transition.shape=</span><span class="si">{}</span><span class="s1">, must be (2,2) or &#39;</span>
                             <span class="s1">&#39;(n_states, 2, 2)=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">n_states</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">transition</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid transition matrix: must be non-negative &#39;</span>
                             <span class="s1">&#39;and sum to 1 on each row.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid probability values: prob must be between [0, 1]&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">p_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
        <span class="n">p_state</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">p_state</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">p_state</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_state</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid marginal state distributions: p_state=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_state</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">p_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
        <span class="n">p_init</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">p_init</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">p_init</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_init</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p_init</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid initial state distributions: p_init=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_init</span><span class="p">))</span>

    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">logp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>

    <span class="n">prob_binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">))</span>
    <span class="n">p_state_binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">p_init_binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
        <span class="n">prob_binary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">prob</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="n">prob_binary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>

        <span class="n">p_state_binary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p_state</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="n">p_state_binary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_state</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>

        <span class="n">p_init_binary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p_init</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="n">p_init_binary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_init</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>

        <span class="n">states</span><span class="p">[</span><span class="n">state</span><span class="p">,</span> <span class="p">:],</span> <span class="n">logp</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">viterbi_discriminative</span><span class="p">(</span><span class="n">prob_binary</span><span class="p">,</span>
                                                               <span class="n">transition</span><span class="p">[</span><span class="n">state</span><span class="p">],</span>
                                                               <span class="n">p_state</span><span class="o">=</span><span class="n">p_state_binary</span><span class="p">,</span>
                                                               <span class="n">p_init</span><span class="o">=</span><span class="n">p_init_binary</span><span class="p">,</span>
                                                               <span class="n">return_logp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_logp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">logp</span>

    <span class="k">return</span> <span class="n">states</span></div>


<div class="viewcode-block" id="transition_uniform"><a class="viewcode-back" href="../../generated/librosa.sequence.transition_uniform.html#librosa.sequence.transition_uniform">[docs]</a><span class="k">def</span> <span class="nf">transition_uniform</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Construct a uniform transition matrix over `n_states`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_states : int &gt; 0</span>
<span class="sd">        The number of states</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    transition : np.ndarray [shape=(n_states, n_states)]</span>
<span class="sd">        `transition[i, j] = 1./n_states`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_uniform(3)</span>
<span class="sd">    array([[0.333, 0.333, 0.333],</span>
<span class="sd">           [0.333, 0.333, 0.333],</span>
<span class="sd">           [0.333, 0.333, 0.333]])</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n_states</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;n_states=</span><span class="si">{}</span><span class="s1"> must be a positive integer&#39;</span><span class="p">)</span>

    <span class="n">transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">transition</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">n_states</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transition</span></div>


<div class="viewcode-block" id="transition_loop"><a class="viewcode-back" href="../../generated/librosa.sequence.transition_loop.html#librosa.sequence.transition_loop">[docs]</a><span class="k">def</span> <span class="nf">transition_loop</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">prob</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Construct a self-loop transition matrix over `n_states`.</span>

<span class="sd">    The transition matrix will have the following properties:</span>

<span class="sd">        - `transition[i, i] = p` for all i</span>
<span class="sd">        - `transition[i, j] = (1 - p) / (n_states - 1)` for all `j != i`</span>

<span class="sd">    This type of transition matrix is appropriate when states tend to be</span>
<span class="sd">    locally stable, and there is no additional structure between different</span>
<span class="sd">    states.  This is primarily useful for de-noising frame-wise predictions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_states : int &gt; 1</span>
<span class="sd">        The number of states</span>

<span class="sd">    prob : float in [0, 1] or iterable, length=n_states</span>
<span class="sd">        If a scalar, this is the probability of a self-transition.</span>

<span class="sd">        If a vector of length `n_states`, `p[i]` is the probability of state `i`&#39;s self-transition.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    transition : np.ndarray [shape=(n_states, n_states)]</span>
<span class="sd">        The transition matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_loop(3, 0.5)</span>
<span class="sd">    array([[0.5 , 0.25, 0.25],</span>
<span class="sd">           [0.25, 0.5 , 0.25],</span>
<span class="sd">           [0.25, 0.25, 0.5 ]])</span>

<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_loop(3, [0.8, 0.5, 0.25])</span>
<span class="sd">    array([[0.8  , 0.1  , 0.1  ],</span>
<span class="sd">           [0.25 , 0.5  , 0.25 ],</span>
<span class="sd">           [0.375, 0.375, 0.25 ]])</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n_states</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;n_states=</span><span class="si">{}</span><span class="s1"> must be a positive integer &gt; 1&#39;</span><span class="p">)</span>

    <span class="n">transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="c1"># if it&#39;s a float, make it a vector</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prob</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prob</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;prob=</span><span class="si">{}</span><span class="s1"> must have length equal to n_states=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;prob=</span><span class="si">{}</span><span class="s1"> must have values in the range [0, 1]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prob</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">prob_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prob</span><span class="p">):</span>
        <span class="n">transition</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">prob_i</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_states</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">transition</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob_i</span>

    <span class="k">return</span> <span class="n">transition</span></div>


<div class="viewcode-block" id="transition_cycle"><a class="viewcode-back" href="../../generated/librosa.sequence.transition_cycle.html#librosa.sequence.transition_cycle">[docs]</a><span class="k">def</span> <span class="nf">transition_cycle</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">prob</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Construct a cyclic transition matrix over `n_states`.</span>

<span class="sd">    The transition matrix will have the following properties:</span>

<span class="sd">        - `transition[i, i] = p`</span>
<span class="sd">        - `transition[i, i + 1] = (1 - p)`</span>

<span class="sd">    This type of transition matrix is appropriate for state spaces</span>
<span class="sd">    with cyclical structure, such as metrical position within a bar.</span>
<span class="sd">    For example, a song in 4/4 time has state transitions of the form</span>

<span class="sd">        1-&gt;{1, 2}, 2-&gt;{2, 3}, 3-&gt;{3, 4}, 4-&gt;{4, 1}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_states : int &gt; 1</span>
<span class="sd">        The number of states</span>

<span class="sd">    prob : float in [0, 1] or iterable, length=n_states</span>
<span class="sd">        If a scalar, this is the probability of a self-transition.</span>

<span class="sd">        If a vector of length `n_states`, `p[i]` is the probability of state</span>
<span class="sd">        `i`&#39;s self-transition.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    transition : np.ndarray [shape=(n_states, n_states)]</span>
<span class="sd">        The transition matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_cycle(4, 0.9)</span>
<span class="sd">    array([[0.9, 0.1, 0. , 0. ],</span>
<span class="sd">           [0. , 0.9, 0.1, 0. ],</span>
<span class="sd">           [0. , 0. , 0.9, 0.1],</span>
<span class="sd">           [0.1, 0. , 0. , 0.9]])</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n_states</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;n_states=</span><span class="si">{}</span><span class="s1"> must be a positive integer &gt; 1&#39;</span><span class="p">)</span>

    <span class="n">transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="c1"># if it&#39;s a float, make it a vector</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prob</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prob</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;prob=</span><span class="si">{}</span><span class="s1"> must have length equal to n_states=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;prob=</span><span class="si">{}</span><span class="s1"> must have values in the range [0, 1]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prob</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">prob_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prob</span><span class="p">):</span>
        <span class="n">transition</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">prob_i</span>
        <span class="n">transition</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob_i</span>

    <span class="k">return</span> <span class="n">transition</span></div>


<div class="viewcode-block" id="transition_local"><a class="viewcode-back" href="../../generated/librosa.sequence.transition_local.html#librosa.sequence.transition_local">[docs]</a><span class="k">def</span> <span class="nf">transition_local</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;triangle&#39;</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Construct a localized transition matrix.</span>

<span class="sd">    The transition matrix will have the following properties:</span>

<span class="sd">        - `transition[i, j] = 0` if `|i - j| &gt; width`</span>
<span class="sd">        - `transition[i, i]` is maximal</span>
<span class="sd">        - `transition[i, i - width//2 : i + width//2]` has shape `window`</span>

<span class="sd">    This type of transition matrix is appropriate for state spaces</span>
<span class="sd">    that discretely approximate continuous variables, such as in fundamental</span>
<span class="sd">    frequency estimation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_states : int &gt; 1</span>
<span class="sd">        The number of states</span>

<span class="sd">    width : int &gt;= 1 or iterable</span>
<span class="sd">        The maximum number of states to treat as &quot;local&quot;.</span>
<span class="sd">        If iterable, it should have length equal to `n_states`,</span>
<span class="sd">        and specify the width independently for each state.</span>

<span class="sd">    window : str, callable, or window specification</span>
<span class="sd">        The window function to determine the shape of the &quot;local&quot; distribution.</span>

<span class="sd">        Any window specification supported by `filters.get_window` will work here.</span>

<span class="sd">        .. note:: Certain windows (e.g., &#39;hann&#39;) are identically 0 at the boundaries,</span>
<span class="sd">            so and effectively have `width-2` non-zero values.  You may have to expand</span>
<span class="sd">            `width` to get the desired behavior.</span>


<span class="sd">    wrap : bool</span>
<span class="sd">        If `True`, then state locality `|i - j|` is computed modulo `n_states`.</span>
<span class="sd">        If `False` (default), then locality is absolute.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    filters.get_window</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    transition : np.ndarray [shape=(n_states, n_states)]</span>
<span class="sd">        The transition matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Triangular distributions with and without wrapping</span>

<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_local(5, 3, window=&#39;triangle&#39;, wrap=False)</span>
<span class="sd">    array([[0.667, 0.333, 0.   , 0.   , 0.   ],</span>
<span class="sd">           [0.25 , 0.5  , 0.25 , 0.   , 0.   ],</span>
<span class="sd">           [0.   , 0.25 , 0.5  , 0.25 , 0.   ],</span>
<span class="sd">           [0.   , 0.   , 0.25 , 0.5  , 0.25 ],</span>
<span class="sd">           [0.   , 0.   , 0.   , 0.333, 0.667]])</span>

<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_local(5, 3, window=&#39;triangle&#39;, wrap=True)</span>
<span class="sd">    array([[0.5 , 0.25, 0.  , 0.  , 0.25],</span>
<span class="sd">           [0.25, 0.5 , 0.25, 0.  , 0.  ],</span>
<span class="sd">           [0.  , 0.25, 0.5 , 0.25, 0.  ],</span>
<span class="sd">           [0.  , 0.  , 0.25, 0.5 , 0.25],</span>
<span class="sd">           [0.25, 0.  , 0.  , 0.25, 0.5 ]])</span>

<span class="sd">    Uniform local distributions with variable widths and no wrapping</span>

<span class="sd">    &gt;&gt;&gt; librosa.sequence.transition_local(5, [1, 2, 3, 3, 1], window=&#39;ones&#39;, wrap=False)</span>
<span class="sd">    array([[1.   , 0.   , 0.   , 0.   , 0.   ],</span>
<span class="sd">           [0.5  , 0.5  , 0.   , 0.   , 0.   ],</span>
<span class="sd">           [0.   , 0.333, 0.333, 0.333, 0.   ],</span>
<span class="sd">           [0.   , 0.   , 0.333, 0.333, 0.333],</span>
<span class="sd">           [0.   , 0.   , 0.   , 0.   , 1.   ]])</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n_states</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;n_states=</span><span class="si">{}</span><span class="s1"> must be a positive integer &gt; 1&#39;</span><span class="p">)</span>

    <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">width</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">width</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_states</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;width=</span><span class="si">{}</span><span class="s1"> must have length equal to n_states=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">n_states</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">width</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;width=</span><span class="si">{}</span><span class="s1"> must be at least 1&#39;</span><span class="p">)</span>

    <span class="n">transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="c1"># Fill in the widths.  This is inefficient, but simple</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">width_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
        <span class="n">trans_row</span> <span class="o">=</span> <span class="n">pad_center</span><span class="p">(</span><span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">width_i</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">n_states</span><span class="p">)</span>
        <span class="n">trans_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">trans_row</span><span class="p">,</span> <span class="n">n_states</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="c1"># Knock out the off-diagonal-band elements</span>
            <span class="n">trans_row</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">width_i</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">trans_row</span><span class="p">[:</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">width_i</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">transition</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_row</span>

    <span class="c1"># Row-normalize</span>
    <span class="n">transition</span> <span class="o">/=</span> <span class="n">transition</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">transition</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013--2019, librosa development team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
        <span class="fa fa-book"> Other Versions</span>
        v: master
        <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Tags</dt>
            <dd><a href="../../../0.4.1/index.html">0.4.1</a></dd>
            <dd><a href="../../../0.4.2/index.html">0.4.2</a></dd>
            <dd><a href="../../../0.4.3/index.html">0.4.3</a></dd>
            <dd><a href="../../../0.5.0/index.html">0.5.0</a></dd>
            <dd><a href="../../../0.5.1/index.html">0.5.1</a></dd>
            <dd><a href="../../../0.6.0/index.html">0.6.0</a></dd>
            <dd><a href="../../../0.6.1/index.html">0.6.1</a></dd>
            <dd><a href="../../../0.6.2/index.html">0.6.2</a></dd>
            <dd><a href="../../../0.6.3/index.html">0.6.3</a></dd>
            <dd><a href="../../../0.7.0/index.html">0.7.0</a></dd>
            <dd><a href="../../../0.7.1/index.html">0.7.1</a></dd>
            <dd><a href="../../../0.7.2/index.html">0.7.2</a></dd>
            <dd><a href="../../../v0.1.0/index.html">v0.1.0</a></dd>
            <dd><a href="../../../v0.4.0/index.html">v0.4.0</a></dd>
        </dl>
        <dl>
            <dt>Branches</dt>
            <dd><a href="sequence.html">master</a></dd>
        </dl>
    </div>
</div>


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>